-----------------------------------------------------------------------
--  util-encoders-aes -- AES encryption and decryption
--  Copyright (C) 2017, 2019, 2020, 2021, 2022 Stephane Carrez
--  Written by Stephane Carrez (Stephane.Carrez@gmail.com)
--
--  Licensed under the Apache License, Version 2.0 (the "License");
--  you may not use this file except in compliance with the License.
--  You may obtain a copy of the License at
--
--      http://www.apache.org/licenses/LICENSE-2.0
--
--  Unless required by applicable law or agreed to in writing, software
--  distributed under the License is distributed on an "AS IS" BASIS,
--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
--  See the License for the specific language governing permissions and
--  limitations under the License.
-----------------------------------------------------------------------
pragma Ada_2022;
with Ada.Text_IO;

package body Util.Encoders.AES is

   type Sbox is array (Unsigned_32 range 0 .. 255) of Unsigned_32;
   type Final_Sbox is array (Unsigned_32 range 0 .. 255) of Unsigned_8;
   type Key_Sbox is array (Natural range 0 .. 9) of Unsigned_32;

   function To_Unsigned_32
     (Data : in Stream_Element_Array; Offset : in Stream_Element_Offset)
      return Unsigned_32;
   pragma Inline_Always (To_Unsigned_32);

   procedure Put_Unsigned_32
     (Data   : in out Stream_Element_Array; Value : in Unsigned_32;
      Offset : in     Stream_Element_Offset);

   Te0 : constant Sbox :=
     (16#c663_63a5#, 16#f87c_7c84#, 16#ee77_7799#, 16#f67b_7b8d#,
      16#fff2_f20d#, 16#d66b_6bbd#, 16#de6f_6fb1#, 16#91c5_c554#,
      16#6030_3050#, 16#0201_0103#, 16#ce67_67a9#, 16#562b_2b7d#,
      16#e7fe_fe19#, 16#b5d7_d762#, 16#4dab_abe6#, 16#ec76_769a#,
      16#8fca_ca45#, 16#1f82_829d#, 16#89c9_c940#, 16#fa7d_7d87#,
      16#effa_fa15#, 16#b259_59eb#, 16#8e47_47c9#, 16#fbf0_f00b#,
      16#41ad_adec#, 16#b3d4_d467#, 16#5fa2_a2fd#, 16#45af_afea#,
      16#239c_9cbf#, 16#53a4_a4f7#, 16#e472_7296#, 16#9bc0_c05b#,
      16#75b7_b7c2#, 16#e1fd_fd1c#, 16#3d93_93ae#, 16#4c26_266a#,
      16#6c36_365a#, 16#7e3f_3f41#, 16#f5f7_f702#, 16#83cc_cc4f#,
      16#6834_345c#, 16#51a5_a5f4#, 16#d1e5_e534#, 16#f9f1_f108#,
      16#e271_7193#, 16#abd8_d873#, 16#6231_3153#, 16#2a15_153f#,
      16#0804_040c#, 16#95c7_c752#, 16#4623_2365#, 16#9dc3_c35e#,
      16#3018_1828#, 16#3796_96a1#, 16#0a05_050f#, 16#2f9a_9ab5#,
      16#0e07_0709#, 16#2412_1236#, 16#1b80_809b#, 16#dfe2_e23d#,
      16#cdeb_eb26#, 16#4e27_2769#, 16#7fb2_b2cd#, 16#ea75_759f#,
      16#1209_091b#, 16#1d83_839e#, 16#582c_2c74#, 16#341a_1a2e#,
      16#361b_1b2d#, 16#dc6e_6eb2#, 16#b45a_5aee#, 16#5ba0_a0fb#,
      16#a452_52f6#, 16#763b_3b4d#, 16#b7d6_d661#, 16#7db3_b3ce#,
      16#5229_297b#, 16#dde3_e33e#, 16#5e2f_2f71#, 16#1384_8497#,
      16#a653_53f5#, 16#b9d1_d168#, 16#0000_0000#, 16#c1ed_ed2c#,
      16#4020_2060#, 16#e3fc_fc1f#, 16#79b1_b1c8#, 16#b65b_5bed#,
      16#d46a_6abe#, 16#8dcb_cb46#, 16#67be_bed9#, 16#7239_394b#,
      16#944a_4ade#, 16#984c_4cd4#, 16#b058_58e8#, 16#85cf_cf4a#,
      16#bbd0_d06b#, 16#c5ef_ef2a#, 16#4faa_aae5#, 16#edfb_fb16#,
      16#8643_43c5#, 16#9a4d_4dd7#, 16#6633_3355#, 16#1185_8594#,
      16#8a45_45cf#, 16#e9f9_f910#, 16#0402_0206#, 16#fe7f_7f81#,
      16#a050_50f0#, 16#783c_3c44#, 16#259f_9fba#, 16#4ba8_a8e3#,
      16#a251_51f3#, 16#5da3_a3fe#, 16#8040_40c0#, 16#058f_8f8a#,
      16#3f92_92ad#, 16#219d_9dbc#, 16#7038_3848#, 16#f1f5_f504#,
      16#63bc_bcdf#, 16#77b6_b6c1#, 16#afda_da75#, 16#4221_2163#,
      16#2010_1030#, 16#e5ff_ff1a#, 16#fdf3_f30e#, 16#bfd2_d26d#,
      16#81cd_cd4c#, 16#180c_0c14#, 16#2613_1335#, 16#c3ec_ec2f#,
      16#be5f_5fe1#, 16#3597_97a2#, 16#8844_44cc#, 16#2e17_1739#,
      16#93c4_c457#, 16#55a7_a7f2#, 16#fc7e_7e82#, 16#7a3d_3d47#,
      16#c864_64ac#, 16#ba5d_5de7#, 16#3219_192b#, 16#e673_7395#,
      16#c060_60a0#, 16#1981_8198#, 16#9e4f_4fd1#, 16#a3dc_dc7f#,
      16#4422_2266#, 16#542a_2a7e#, 16#3b90_90ab#, 16#0b88_8883#,
      16#8c46_46ca#, 16#c7ee_ee29#, 16#6bb8_b8d3#, 16#2814_143c#,
      16#a7de_de79#, 16#bc5e_5ee2#, 16#160b_0b1d#, 16#addb_db76#,
      16#dbe0_e03b#, 16#6432_3256#, 16#743a_3a4e#, 16#140a_0a1e#,
      16#9249_49db#, 16#0c06_060a#, 16#4824_246c#, 16#b85c_5ce4#,
      16#9fc2_c25d#, 16#bdd3_d36e#, 16#43ac_acef#, 16#c462_62a6#,
      16#3991_91a8#, 16#3195_95a4#, 16#d3e4_e437#, 16#f279_798b#,
      16#d5e7_e732#, 16#8bc8_c843#, 16#6e37_3759#, 16#da6d_6db7#,
      16#018d_8d8c#, 16#b1d5_d564#, 16#9c4e_4ed2#, 16#49a9_a9e0#,
      16#d86c_6cb4#, 16#ac56_56fa#, 16#f3f4_f407#, 16#cfea_ea25#,
      16#ca65_65af#, 16#f47a_7a8e#, 16#47ae_aee9#, 16#1008_0818#,
      16#6fba_bad5#, 16#f078_7888#, 16#4a25_256f#, 16#5c2e_2e72#,
      16#381c_1c24#, 16#57a6_a6f1#, 16#73b4_b4c7#, 16#97c6_c651#,
      16#cbe8_e823#, 16#a1dd_dd7c#, 16#e874_749c#, 16#3e1f_1f21#,
      16#964b_4bdd#, 16#61bd_bddc#, 16#0d8b_8b86#, 16#0f8a_8a85#,
      16#e070_7090#, 16#7c3e_3e42#, 16#71b5_b5c4#, 16#cc66_66aa#,
      16#9048_48d8#, 16#0603_0305#, 16#f7f6_f601#, 16#1c0e_0e12#,
      16#c261_61a3#, 16#6a35_355f#, 16#ae57_57f9#, 16#69b9_b9d0#,
      16#1786_8691#, 16#99c1_c158#, 16#3a1d_1d27#, 16#279e_9eb9#,
      16#d9e1_e138#, 16#ebf8_f813#, 16#2b98_98b3#, 16#2211_1133#,
      16#d269_69bb#, 16#a9d9_d970#, 16#078e_8e89#, 16#3394_94a7#,
      16#2d9b_9bb6#, 16#3c1e_1e22#, 16#1587_8792#, 16#c9e9_e920#,
      16#87ce_ce49#, 16#aa55_55ff#, 16#5028_2878#, 16#a5df_df7a#,
      16#038c_8c8f#, 16#59a1_a1f8#, 16#0989_8980#, 16#1a0d_0d17#,
      16#65bf_bfda#, 16#d7e6_e631#, 16#8442_42c6#, 16#d068_68b8#,
      16#8241_41c3#, 16#2999_99b0#, 16#5a2d_2d77#, 16#1e0f_0f11#,
      16#7bb0_b0cb#, 16#a854_54fc#, 16#6dbb_bbd6#, 16#2c16_163a#);

   Te1 : constant Sbox :=
     (16#a5c6_6363#, 16#84f8_7c7c#, 16#99ee_7777#, 16#8df6_7b7b#,
      16#0dff_f2f2#, 16#bdd6_6b6b#, 16#b1de_6f6f#, 16#5491_c5c5#,
      16#5060_3030#, 16#0302_0101#, 16#a9ce_6767#, 16#7d56_2b2b#,
      16#19e7_fefe#, 16#62b5_d7d7#, 16#e64d_abab#, 16#9aec_7676#,
      16#458f_caca#, 16#9d1f_8282#, 16#4089_c9c9#, 16#87fa_7d7d#,
      16#15ef_fafa#, 16#ebb2_5959#, 16#c98e_4747#, 16#0bfb_f0f0#,
      16#ec41_adad#, 16#67b3_d4d4#, 16#fd5f_a2a2#, 16#ea45_afaf#,
      16#bf23_9c9c#, 16#f753_a4a4#, 16#96e4_7272#, 16#5b9b_c0c0#,
      16#c275_b7b7#, 16#1ce1_fdfd#, 16#ae3d_9393#, 16#6a4c_2626#,
      16#5a6c_3636#, 16#417e_3f3f#, 16#02f5_f7f7#, 16#4f83_cccc#,
      16#5c68_3434#, 16#f451_a5a5#, 16#34d1_e5e5#, 16#08f9_f1f1#,
      16#93e2_7171#, 16#73ab_d8d8#, 16#5362_3131#, 16#3f2a_1515#,
      16#0c08_0404#, 16#5295_c7c7#, 16#6546_2323#, 16#5e9d_c3c3#,
      16#2830_1818#, 16#a137_9696#, 16#0f0a_0505#, 16#b52f_9a9a#,
      16#090e_0707#, 16#3624_1212#, 16#9b1b_8080#, 16#3ddf_e2e2#,
      16#26cd_ebeb#, 16#694e_2727#, 16#cd7f_b2b2#, 16#9fea_7575#,
      16#1b12_0909#, 16#9e1d_8383#, 16#7458_2c2c#, 16#2e34_1a1a#,
      16#2d36_1b1b#, 16#b2dc_6e6e#, 16#eeb4_5a5a#, 16#fb5b_a0a0#,
      16#f6a4_5252#, 16#4d76_3b3b#, 16#61b7_d6d6#, 16#ce7d_b3b3#,
      16#7b52_2929#, 16#3edd_e3e3#, 16#715e_2f2f#, 16#9713_8484#,
      16#f5a6_5353#, 16#68b9_d1d1#, 16#0000_0000#, 16#2cc1_eded#,
      16#6040_2020#, 16#1fe3_fcfc#, 16#c879_b1b1#, 16#edb6_5b5b#,
      16#bed4_6a6a#, 16#468d_cbcb#, 16#d967_bebe#, 16#4b72_3939#,
      16#de94_4a4a#, 16#d498_4c4c#, 16#e8b0_5858#, 16#4a85_cfcf#,
      16#6bbb_d0d0#, 16#2ac5_efef#, 16#e54f_aaaa#, 16#16ed_fbfb#,
      16#c586_4343#, 16#d79a_4d4d#, 16#5566_3333#, 16#9411_8585#,
      16#cf8a_4545#, 16#10e9_f9f9#, 16#0604_0202#, 16#81fe_7f7f#,
      16#f0a0_5050#, 16#4478_3c3c#, 16#ba25_9f9f#, 16#e34b_a8a8#,
      16#f3a2_5151#, 16#fe5d_a3a3#, 16#c080_4040#, 16#8a05_8f8f#,
      16#ad3f_9292#, 16#bc21_9d9d#, 16#4870_3838#, 16#04f1_f5f5#,
      16#df63_bcbc#, 16#c177_b6b6#, 16#75af_dada#, 16#6342_2121#,
      16#3020_1010#, 16#1ae5_ffff#, 16#0efd_f3f3#, 16#6dbf_d2d2#,
      16#4c81_cdcd#, 16#1418_0c0c#, 16#3526_1313#, 16#2fc3_ecec#,
      16#e1be_5f5f#, 16#a235_9797#, 16#cc88_4444#, 16#392e_1717#,
      16#5793_c4c4#, 16#f255_a7a7#, 16#82fc_7e7e#, 16#477a_3d3d#,
      16#acc8_6464#, 16#e7ba_5d5d#, 16#2b32_1919#, 16#95e6_7373#,
      16#a0c0_6060#, 16#9819_8181#, 16#d19e_4f4f#, 16#7fa3_dcdc#,
      16#6644_2222#, 16#7e54_2a2a#, 16#ab3b_9090#, 16#830b_8888#,
      16#ca8c_4646#, 16#29c7_eeee#, 16#d36b_b8b8#, 16#3c28_1414#,
      16#79a7_dede#, 16#e2bc_5e5e#, 16#1d16_0b0b#, 16#76ad_dbdb#,
      16#3bdb_e0e0#, 16#5664_3232#, 16#4e74_3a3a#, 16#1e14_0a0a#,
      16#db92_4949#, 16#0a0c_0606#, 16#6c48_2424#, 16#e4b8_5c5c#,
      16#5d9f_c2c2#, 16#6ebd_d3d3#, 16#ef43_acac#, 16#a6c4_6262#,
      16#a839_9191#, 16#a431_9595#, 16#37d3_e4e4#, 16#8bf2_7979#,
      16#32d5_e7e7#, 16#438b_c8c8#, 16#596e_3737#, 16#b7da_6d6d#,
      16#8c01_8d8d#, 16#64b1_d5d5#, 16#d29c_4e4e#, 16#e049_a9a9#,
      16#b4d8_6c6c#, 16#faac_5656#, 16#07f3_f4f4#, 16#25cf_eaea#,
      16#afca_6565#, 16#8ef4_7a7a#, 16#e947_aeae#, 16#1810_0808#,
      16#d56f_baba#, 16#88f0_7878#, 16#6f4a_2525#, 16#725c_2e2e#,
      16#2438_1c1c#, 16#f157_a6a6#, 16#c773_b4b4#, 16#5197_c6c6#,
      16#23cb_e8e8#, 16#7ca1_dddd#, 16#9ce8_7474#, 16#213e_1f1f#,
      16#dd96_4b4b#, 16#dc61_bdbd#, 16#860d_8b8b#, 16#850f_8a8a#,
      16#90e0_7070#, 16#427c_3e3e#, 16#c471_b5b5#, 16#aacc_6666#,
      16#d890_4848#, 16#0506_0303#, 16#01f7_f6f6#, 16#121c_0e0e#,
      16#a3c2_6161#, 16#5f6a_3535#, 16#f9ae_5757#, 16#d069_b9b9#,
      16#9117_8686#, 16#5899_c1c1#, 16#273a_1d1d#, 16#b927_9e9e#,
      16#38d9_e1e1#, 16#13eb_f8f8#, 16#b32b_9898#, 16#3322_1111#,
      16#bbd2_6969#, 16#70a9_d9d9#, 16#8907_8e8e#, 16#a733_9494#,
      16#b62d_9b9b#, 16#223c_1e1e#, 16#9215_8787#, 16#20c9_e9e9#,
      16#4987_cece#, 16#ffaa_5555#, 16#7850_2828#, 16#7aa5_dfdf#,
      16#8f03_8c8c#, 16#f859_a1a1#, 16#8009_8989#, 16#171a_0d0d#,
      16#da65_bfbf#, 16#31d7_e6e6#, 16#c684_4242#, 16#b8d0_6868#,
      16#c382_4141#, 16#b029_9999#, 16#775a_2d2d#, 16#111e_0f0f#,
      16#cb7b_b0b0#, 16#fca8_5454#, 16#d66d_bbbb#, 16#3a2c_1616#);

   Te2 : constant Sbox :=
     (16#63a5_c663#, 16#7c84_f87c#, 16#7799_ee77#, 16#7b8d_f67b#,
      16#f20d_fff2#, 16#6bbd_d66b#, 16#6fb1_de6f#, 16#c554_91c5#,
      16#3050_6030#, 16#0103_0201#, 16#67a9_ce67#, 16#2b7d_562b#,
      16#fe19_e7fe#, 16#d762_b5d7#, 16#abe6_4dab#, 16#769a_ec76#,
      16#ca45_8fca#, 16#829d_1f82#, 16#c940_89c9#, 16#7d87_fa7d#,
      16#fa15_effa#, 16#59eb_b259#, 16#47c9_8e47#, 16#f00b_fbf0#,
      16#adec_41ad#, 16#d467_b3d4#, 16#a2fd_5fa2#, 16#afea_45af#,
      16#9cbf_239c#, 16#a4f7_53a4#, 16#7296_e472#, 16#c05b_9bc0#,
      16#b7c2_75b7#, 16#fd1c_e1fd#, 16#93ae_3d93#, 16#266a_4c26#,
      16#365a_6c36#, 16#3f41_7e3f#, 16#f702_f5f7#, 16#cc4f_83cc#,
      16#345c_6834#, 16#a5f4_51a5#, 16#e534_d1e5#, 16#f108_f9f1#,
      16#7193_e271#, 16#d873_abd8#, 16#3153_6231#, 16#153f_2a15#,
      16#040c_0804#, 16#c752_95c7#, 16#2365_4623#, 16#c35e_9dc3#,
      16#1828_3018#, 16#96a1_3796#, 16#050f_0a05#, 16#9ab5_2f9a#,
      16#0709_0e07#, 16#1236_2412#, 16#809b_1b80#, 16#e23d_dfe2#,
      16#eb26_cdeb#, 16#2769_4e27#, 16#b2cd_7fb2#, 16#759f_ea75#,
      16#091b_1209#, 16#839e_1d83#, 16#2c74_582c#, 16#1a2e_341a#,
      16#1b2d_361b#, 16#6eb2_dc6e#, 16#5aee_b45a#, 16#a0fb_5ba0#,
      16#52f6_a452#, 16#3b4d_763b#, 16#d661_b7d6#, 16#b3ce_7db3#,
      16#297b_5229#, 16#e33e_dde3#, 16#2f71_5e2f#, 16#8497_1384#,
      16#53f5_a653#, 16#d168_b9d1#, 16#0000_0000#, 16#ed2c_c1ed#,
      16#2060_4020#, 16#fc1f_e3fc#, 16#b1c8_79b1#, 16#5bed_b65b#,
      16#6abe_d46a#, 16#cb46_8dcb#, 16#bed9_67be#, 16#394b_7239#,
      16#4ade_944a#, 16#4cd4_984c#, 16#58e8_b058#, 16#cf4a_85cf#,
      16#d06b_bbd0#, 16#ef2a_c5ef#, 16#aae5_4faa#, 16#fb16_edfb#,
      16#43c5_8643#, 16#4dd7_9a4d#, 16#3355_6633#, 16#8594_1185#,
      16#45cf_8a45#, 16#f910_e9f9#, 16#0206_0402#, 16#7f81_fe7f#,
      16#50f0_a050#, 16#3c44_783c#, 16#9fba_259f#, 16#a8e3_4ba8#,
      16#51f3_a251#, 16#a3fe_5da3#, 16#40c0_8040#, 16#8f8a_058f#,
      16#92ad_3f92#, 16#9dbc_219d#, 16#3848_7038#, 16#f504_f1f5#,
      16#bcdf_63bc#, 16#b6c1_77b6#, 16#da75_afda#, 16#2163_4221#,
      16#1030_2010#, 16#ff1a_e5ff#, 16#f30e_fdf3#, 16#d26d_bfd2#,
      16#cd4c_81cd#, 16#0c14_180c#, 16#1335_2613#, 16#ec2f_c3ec#,
      16#5fe1_be5f#, 16#97a2_3597#, 16#44cc_8844#, 16#1739_2e17#,
      16#c457_93c4#, 16#a7f2_55a7#, 16#7e82_fc7e#, 16#3d47_7a3d#,
      16#64ac_c864#, 16#5de7_ba5d#, 16#192b_3219#, 16#7395_e673#,
      16#60a0_c060#, 16#8198_1981#, 16#4fd1_9e4f#, 16#dc7f_a3dc#,
      16#2266_4422#, 16#2a7e_542a#, 16#90ab_3b90#, 16#8883_0b88#,
      16#46ca_8c46#, 16#ee29_c7ee#, 16#b8d3_6bb8#, 16#143c_2814#,
      16#de79_a7de#, 16#5ee2_bc5e#, 16#0b1d_160b#, 16#db76_addb#,
      16#e03b_dbe0#, 16#3256_6432#, 16#3a4e_743a#, 16#0a1e_140a#,
      16#49db_9249#, 16#060a_0c06#, 16#246c_4824#, 16#5ce4_b85c#,
      16#c25d_9fc2#, 16#d36e_bdd3#, 16#acef_43ac#, 16#62a6_c462#,
      16#91a8_3991#, 16#95a4_3195#, 16#e437_d3e4#, 16#798b_f279#,
      16#e732_d5e7#, 16#c843_8bc8#, 16#3759_6e37#, 16#6db7_da6d#,
      16#8d8c_018d#, 16#d564_b1d5#, 16#4ed2_9c4e#, 16#a9e0_49a9#,
      16#6cb4_d86c#, 16#56fa_ac56#, 16#f407_f3f4#, 16#ea25_cfea#,
      16#65af_ca65#, 16#7a8e_f47a#, 16#aee9_47ae#, 16#0818_1008#,
      16#bad5_6fba#, 16#7888_f078#, 16#256f_4a25#, 16#2e72_5c2e#,
      16#1c24_381c#, 16#a6f1_57a6#, 16#b4c7_73b4#, 16#c651_97c6#,
      16#e823_cbe8#, 16#dd7c_a1dd#, 16#749c_e874#, 16#1f21_3e1f#,
      16#4bdd_964b#, 16#bddc_61bd#, 16#8b86_0d8b#, 16#8a85_0f8a#,
      16#7090_e070#, 16#3e42_7c3e#, 16#b5c4_71b5#, 16#66aa_cc66#,
      16#48d8_9048#, 16#0305_0603#, 16#f601_f7f6#, 16#0e12_1c0e#,
      16#61a3_c261#, 16#355f_6a35#, 16#57f9_ae57#, 16#b9d0_69b9#,
      16#8691_1786#, 16#c158_99c1#, 16#1d27_3a1d#, 16#9eb9_279e#,
      16#e138_d9e1#, 16#f813_ebf8#, 16#98b3_2b98#, 16#1133_2211#,
      16#69bb_d269#, 16#d970_a9d9#, 16#8e89_078e#, 16#94a7_3394#,
      16#9bb6_2d9b#, 16#1e22_3c1e#, 16#8792_1587#, 16#e920_c9e9#,
      16#ce49_87ce#, 16#55ff_aa55#, 16#2878_5028#, 16#df7a_a5df#,
      16#8c8f_038c#, 16#a1f8_59a1#, 16#8980_0989#, 16#0d17_1a0d#,
      16#bfda_65bf#, 16#e631_d7e6#, 16#42c6_8442#, 16#68b8_d068#,
      16#41c3_8241#, 16#99b0_2999#, 16#2d77_5a2d#, 16#0f11_1e0f#,
      16#b0cb_7bb0#, 16#54fc_a854#, 16#bbd6_6dbb#, 16#163a_2c16#);

   Te3 : constant Sbox :=
     (16#6363_a5c6#, 16#7c7c_84f8#, 16#7777_99ee#, 16#7b7b_8df6#,
      16#f2f2_0dff#, 16#6b6b_bdd6#, 16#6f6f_b1de#, 16#c5c5_5491#,
      16#3030_5060#, 16#0101_0302#, 16#6767_a9ce#, 16#2b2b_7d56#,
      16#fefe_19e7#, 16#d7d7_62b5#, 16#abab_e64d#, 16#7676_9aec#,
      16#caca_458f#, 16#8282_9d1f#, 16#c9c9_4089#, 16#7d7d_87fa#,
      16#fafa_15ef#, 16#5959_ebb2#, 16#4747_c98e#, 16#f0f0_0bfb#,
      16#adad_ec41#, 16#d4d4_67b3#, 16#a2a2_fd5f#, 16#afaf_ea45#,
      16#9c9c_bf23#, 16#a4a4_f753#, 16#7272_96e4#, 16#c0c0_5b9b#,
      16#b7b7_c275#, 16#fdfd_1ce1#, 16#9393_ae3d#, 16#2626_6a4c#,
      16#3636_5a6c#, 16#3f3f_417e#, 16#f7f7_02f5#, 16#cccc_4f83#,
      16#3434_5c68#, 16#a5a5_f451#, 16#e5e5_34d1#, 16#f1f1_08f9#,
      16#7171_93e2#, 16#d8d8_73ab#, 16#3131_5362#, 16#1515_3f2a#,
      16#0404_0c08#, 16#c7c7_5295#, 16#2323_6546#, 16#c3c3_5e9d#,
      16#1818_2830#, 16#9696_a137#, 16#0505_0f0a#, 16#9a9a_b52f#,
      16#0707_090e#, 16#1212_3624#, 16#8080_9b1b#, 16#e2e2_3ddf#,
      16#ebeb_26cd#, 16#2727_694e#, 16#b2b2_cd7f#, 16#7575_9fea#,
      16#0909_1b12#, 16#8383_9e1d#, 16#2c2c_7458#, 16#1a1a_2e34#,
      16#1b1b_2d36#, 16#6e6e_b2dc#, 16#5a5a_eeb4#, 16#a0a0_fb5b#,
      16#5252_f6a4#, 16#3b3b_4d76#, 16#d6d6_61b7#, 16#b3b3_ce7d#,
      16#2929_7b52#, 16#e3e3_3edd#, 16#2f2f_715e#, 16#8484_9713#,
      16#5353_f5a6#, 16#d1d1_68b9#, 16#0000_0000#, 16#eded_2cc1#,
      16#2020_6040#, 16#fcfc_1fe3#, 16#b1b1_c879#, 16#5b5b_edb6#,
      16#6a6a_bed4#, 16#cbcb_468d#, 16#bebe_d967#, 16#3939_4b72#,
      16#4a4a_de94#, 16#4c4c_d498#, 16#5858_e8b0#, 16#cfcf_4a85#,
      16#d0d0_6bbb#, 16#efef_2ac5#, 16#aaaa_e54f#, 16#fbfb_16ed#,
      16#4343_c586#, 16#4d4d_d79a#, 16#3333_5566#, 16#8585_9411#,
      16#4545_cf8a#, 16#f9f9_10e9#, 16#0202_0604#, 16#7f7f_81fe#,
      16#5050_f0a0#, 16#3c3c_4478#, 16#9f9f_ba25#, 16#a8a8_e34b#,
      16#5151_f3a2#, 16#a3a3_fe5d#, 16#4040_c080#, 16#8f8f_8a05#,
      16#9292_ad3f#, 16#9d9d_bc21#, 16#3838_4870#, 16#f5f5_04f1#,
      16#bcbc_df63#, 16#b6b6_c177#, 16#dada_75af#, 16#2121_6342#,
      16#1010_3020#, 16#ffff_1ae5#, 16#f3f3_0efd#, 16#d2d2_6dbf#,
      16#cdcd_4c81#, 16#0c0c_1418#, 16#1313_3526#, 16#ecec_2fc3#,
      16#5f5f_e1be#, 16#9797_a235#, 16#4444_cc88#, 16#1717_392e#,
      16#c4c4_5793#, 16#a7a7_f255#, 16#7e7e_82fc#, 16#3d3d_477a#,
      16#6464_acc8#, 16#5d5d_e7ba#, 16#1919_2b32#, 16#7373_95e6#,
      16#6060_a0c0#, 16#8181_9819#, 16#4f4f_d19e#, 16#dcdc_7fa3#,
      16#2222_6644#, 16#2a2a_7e54#, 16#9090_ab3b#, 16#8888_830b#,
      16#4646_ca8c#, 16#eeee_29c7#, 16#b8b8_d36b#, 16#1414_3c28#,
      16#dede_79a7#, 16#5e5e_e2bc#, 16#0b0b_1d16#, 16#dbdb_76ad#,
      16#e0e0_3bdb#, 16#3232_5664#, 16#3a3a_4e74#, 16#0a0a_1e14#,
      16#4949_db92#, 16#0606_0a0c#, 16#2424_6c48#, 16#5c5c_e4b8#,
      16#c2c2_5d9f#, 16#d3d3_6ebd#, 16#acac_ef43#, 16#6262_a6c4#,
      16#9191_a839#, 16#9595_a431#, 16#e4e4_37d3#, 16#7979_8bf2#,
      16#e7e7_32d5#, 16#c8c8_438b#, 16#3737_596e#, 16#6d6d_b7da#,
      16#8d8d_8c01#, 16#d5d5_64b1#, 16#4e4e_d29c#, 16#a9a9_e049#,
      16#6c6c_b4d8#, 16#5656_faac#, 16#f4f4_07f3#, 16#eaea_25cf#,
      16#6565_afca#, 16#7a7a_8ef4#, 16#aeae_e947#, 16#0808_1810#,
      16#baba_d56f#, 16#7878_88f0#, 16#2525_6f4a#, 16#2e2e_725c#,
      16#1c1c_2438#, 16#a6a6_f157#, 16#b4b4_c773#, 16#c6c6_5197#,
      16#e8e8_23cb#, 16#dddd_7ca1#, 16#7474_9ce8#, 16#1f1f_213e#,
      16#4b4b_dd96#, 16#bdbd_dc61#, 16#8b8b_860d#, 16#8a8a_850f#,
      16#7070_90e0#, 16#3e3e_427c#, 16#b5b5_c471#, 16#6666_aacc#,
      16#4848_d890#, 16#0303_0506#, 16#f6f6_01f7#, 16#0e0e_121c#,
      16#6161_a3c2#, 16#3535_5f6a#, 16#5757_f9ae#, 16#b9b9_d069#,
      16#8686_9117#, 16#c1c1_5899#, 16#1d1d_273a#, 16#9e9e_b927#,
      16#e1e1_38d9#, 16#f8f8_13eb#, 16#9898_b32b#, 16#1111_3322#,
      16#6969_bbd2#, 16#d9d9_70a9#, 16#8e8e_8907#, 16#9494_a733#,
      16#9b9b_b62d#, 16#1e1e_223c#, 16#8787_9215#, 16#e9e9_20c9#,
      16#cece_4987#, 16#5555_ffaa#, 16#2828_7850#, 16#dfdf_7aa5#,
      16#8c8c_8f03#, 16#a1a1_f859#, 16#8989_8009#, 16#0d0d_171a#,
      16#bfbf_da65#, 16#e6e6_31d7#, 16#4242_c684#, 16#6868_b8d0#,
      16#4141_c382#, 16#9999_b029#, 16#2d2d_775a#, 16#0f0f_111e#,
      16#b0b0_cb7b#, 16#5454_fca8#, 16#bbbb_d66d#, 16#1616_3a2c#);

   Te4 : constant Sbox :=
     (16#6363_6363#, 16#7c7c_7c7c#, 16#7777_7777#, 16#7b7b_7b7b#,
      16#f2f2_f2f2#, 16#6b6b_6b6b#, 16#6f6f_6f6f#, 16#c5c5_c5c5#,
      16#3030_3030#, 16#0101_0101#, 16#6767_6767#, 16#2b2b_2b2b#,
      16#fefe_fefe#, 16#d7d7_d7d7#, 16#abab_abab#, 16#7676_7676#,
      16#caca_caca#, 16#8282_8282#, 16#c9c9_c9c9#, 16#7d7d_7d7d#,
      16#fafa_fafa#, 16#5959_5959#, 16#4747_4747#, 16#f0f0_f0f0#,
      16#adad_adad#, 16#d4d4_d4d4#, 16#a2a2_a2a2#, 16#afaf_afaf#,
      16#9c9c_9c9c#, 16#a4a4_a4a4#, 16#7272_7272#, 16#c0c0_c0c0#,
      16#b7b7_b7b7#, 16#fdfd_fdfd#, 16#9393_9393#, 16#2626_2626#,
      16#3636_3636#, 16#3f3f_3f3f#, 16#f7f7_f7f7#, 16#cccc_cccc#,
      16#3434_3434#, 16#a5a5_a5a5#, 16#e5e5_e5e5#, 16#f1f1_f1f1#,
      16#7171_7171#, 16#d8d8_d8d8#, 16#3131_3131#, 16#1515_1515#,
      16#0404_0404#, 16#c7c7_c7c7#, 16#2323_2323#, 16#c3c3_c3c3#,
      16#1818_1818#, 16#9696_9696#, 16#0505_0505#, 16#9a9a_9a9a#,
      16#0707_0707#, 16#1212_1212#, 16#8080_8080#, 16#e2e2_e2e2#,
      16#ebeb_ebeb#, 16#2727_2727#, 16#b2b2_b2b2#, 16#7575_7575#,
      16#0909_0909#, 16#8383_8383#, 16#2c2c_2c2c#, 16#1a1a_1a1a#,
      16#1b1b_1b1b#, 16#6e6e_6e6e#, 16#5a5a_5a5a#, 16#a0a0_a0a0#,
      16#5252_5252#, 16#3b3b_3b3b#, 16#d6d6_d6d6#, 16#b3b3_b3b3#,
      16#2929_2929#, 16#e3e3_e3e3#, 16#2f2f_2f2f#, 16#8484_8484#,
      16#5353_5353#, 16#d1d1_d1d1#, 16#0000_0000#, 16#eded_eded#,
      16#2020_2020#, 16#fcfc_fcfc#, 16#b1b1_b1b1#, 16#5b5b_5b5b#,
      16#6a6a_6a6a#, 16#cbcb_cbcb#, 16#bebe_bebe#, 16#3939_3939#,
      16#4a4a_4a4a#, 16#4c4c_4c4c#, 16#5858_5858#, 16#cfcf_cfcf#,
      16#d0d0_d0d0#, 16#efef_efef#, 16#aaaa_aaaa#, 16#fbfb_fbfb#,
      16#4343_4343#, 16#4d4d_4d4d#, 16#3333_3333#, 16#8585_8585#,
      16#4545_4545#, 16#f9f9_f9f9#, 16#0202_0202#, 16#7f7f_7f7f#,
      16#5050_5050#, 16#3c3c_3c3c#, 16#9f9f_9f9f#, 16#a8a8_a8a8#,
      16#5151_5151#, 16#a3a3_a3a3#, 16#4040_4040#, 16#8f8f_8f8f#,
      16#9292_9292#, 16#9d9d_9d9d#, 16#3838_3838#, 16#f5f5_f5f5#,
      16#bcbc_bcbc#, 16#b6b6_b6b6#, 16#dada_dada#, 16#2121_2121#,
      16#1010_1010#, 16#ffff_ffff#, 16#f3f3_f3f3#, 16#d2d2_d2d2#,
      16#cdcd_cdcd#, 16#0c0c_0c0c#, 16#1313_1313#, 16#ecec_ecec#,
      16#5f5f_5f5f#, 16#9797_9797#, 16#4444_4444#, 16#1717_1717#,
      16#c4c4_c4c4#, 16#a7a7_a7a7#, 16#7e7e_7e7e#, 16#3d3d_3d3d#,
      16#6464_6464#, 16#5d5d_5d5d#, 16#1919_1919#, 16#7373_7373#,
      16#6060_6060#, 16#8181_8181#, 16#4f4f_4f4f#, 16#dcdc_dcdc#,
      16#2222_2222#, 16#2a2a_2a2a#, 16#9090_9090#, 16#8888_8888#,
      16#4646_4646#, 16#eeee_eeee#, 16#b8b8_b8b8#, 16#1414_1414#,
      16#dede_dede#, 16#5e5e_5e5e#, 16#0b0b_0b0b#, 16#dbdb_dbdb#,
      16#e0e0_e0e0#, 16#3232_3232#, 16#3a3a_3a3a#, 16#0a0a_0a0a#,
      16#4949_4949#, 16#0606_0606#, 16#2424_2424#, 16#5c5c_5c5c#,
      16#c2c2_c2c2#, 16#d3d3_d3d3#, 16#acac_acac#, 16#6262_6262#,
      16#9191_9191#, 16#9595_9595#, 16#e4e4_e4e4#, 16#7979_7979#,
      16#e7e7_e7e7#, 16#c8c8_c8c8#, 16#3737_3737#, 16#6d6d_6d6d#,
      16#8d8d_8d8d#, 16#d5d5_d5d5#, 16#4e4e_4e4e#, 16#a9a9_a9a9#,
      16#6c6c_6c6c#, 16#5656_5656#, 16#f4f4_f4f4#, 16#eaea_eaea#,
      16#6565_6565#, 16#7a7a_7a7a#, 16#aeae_aeae#, 16#0808_0808#,
      16#baba_baba#, 16#7878_7878#, 16#2525_2525#, 16#2e2e_2e2e#,
      16#1c1c_1c1c#, 16#a6a6_a6a6#, 16#b4b4_b4b4#, 16#c6c6_c6c6#,
      16#e8e8_e8e8#, 16#dddd_dddd#, 16#7474_7474#, 16#1f1f_1f1f#,
      16#4b4b_4b4b#, 16#bdbd_bdbd#, 16#8b8b_8b8b#, 16#8a8a_8a8a#,
      16#7070_7070#, 16#3e3e_3e3e#, 16#b5b5_b5b5#, 16#6666_6666#,
      16#4848_4848#, 16#0303_0303#, 16#f6f6_f6f6#, 16#0e0e_0e0e#,
      16#6161_6161#, 16#3535_3535#, 16#5757_5757#, 16#b9b9_b9b9#,
      16#8686_8686#, 16#c1c1_c1c1#, 16#1d1d_1d1d#, 16#9e9e_9e9e#,
      16#e1e1_e1e1#, 16#f8f8_f8f8#, 16#9898_9898#, 16#1111_1111#,
      16#6969_6969#, 16#d9d9_d9d9#, 16#8e8e_8e8e#, 16#9494_9494#,
      16#9b9b_9b9b#, 16#1e1e_1e1e#, 16#8787_8787#, 16#e9e9_e9e9#,
      16#cece_cece#, 16#5555_5555#, 16#2828_2828#, 16#dfdf_dfdf#,
      16#8c8c_8c8c#, 16#a1a1_a1a1#, 16#8989_8989#, 16#0d0d_0d0d#,
      16#bfbf_bfbf#, 16#e6e6_e6e6#, 16#4242_4242#, 16#6868_6868#,
      16#4141_4141#, 16#9999_9999#, 16#2d2d_2d2d#, 16#0f0f_0f0f#,
      16#b0b0_b0b0#, 16#5454_5454#, 16#bbbb_bbbb#, 16#1616_1616#);

   Td0 : constant Sbox :=
     (16#51f4_a750#, 16#7e41_6553#, 16#1a17_a4c3#, 16#3a27_5e96#,
      16#3bab_6bcb#, 16#1f9d_45f1#, 16#acfa_58ab#, 16#4be3_0393#,
      16#2030_fa55#, 16#ad76_6df6#, 16#88cc_7691#, 16#f502_4c25#,
      16#4fe5_d7fc#, 16#c52a_cbd7#, 16#2635_4480#, 16#b562_a38f#,
      16#deb1_5a49#, 16#25ba_1b67#, 16#45ea_0e98#, 16#5dfe_c0e1#,
      16#c32f_7502#, 16#814c_f012#, 16#8d46_97a3#, 16#6bd3_f9c6#,
      16#038f_5fe7#, 16#1592_9c95#, 16#bf6d_7aeb#, 16#9552_59da#,
      16#d4be_832d#, 16#5874_21d3#, 16#49e0_6929#, 16#8ec9_c844#,
      16#75c2_896a#, 16#f48e_7978#, 16#9958_3e6b#, 16#27b9_71dd#,
      16#bee1_4fb6#, 16#f088_ad17#, 16#c920_ac66#, 16#7dce_3ab4#,
      16#63df_4a18#, 16#e51a_3182#, 16#9751_3360#, 16#6253_7f45#,
      16#b164_77e0#, 16#bb6b_ae84#, 16#fe81_a01c#, 16#f908_2b94#,
      16#7048_6858#, 16#8f45_fd19#, 16#94de_6c87#, 16#527b_f8b7#,
      16#ab73_d323#, 16#724b_02e2#, 16#e31f_8f57#, 16#6655_ab2a#,
      16#b2eb_2807#, 16#2fb5_c203#, 16#86c5_7b9a#, 16#d337_08a5#,
      16#3028_87f2#, 16#23bf_a5b2#, 16#0203_6aba#, 16#ed16_825c#,
      16#8acf_1c2b#, 16#a779_b492#, 16#f307_f2f0#, 16#4e69_e2a1#,
      16#65da_f4cd#, 16#0605_bed5#, 16#d134_621f#, 16#c4a6_fe8a#,
      16#342e_539d#, 16#a2f3_55a0#, 16#058a_e132#, 16#a4f6_eb75#,
      16#0b83_ec39#, 16#4060_efaa#, 16#5e71_9f06#, 16#bd6e_1051#,
      16#3e21_8af9#, 16#96dd_063d#, 16#dd3e_05ae#, 16#4de6_bd46#,
      16#9154_8db5#, 16#71c4_5d05#, 16#0406_d46f#, 16#6050_15ff#,
      16#1998_fb24#, 16#d6bd_e997#, 16#8940_43cc#, 16#67d9_9e77#,
      16#b0e8_42bd#, 16#0789_8b88#, 16#e719_5b38#, 16#79c8_eedb#,
      16#a17c_0a47#, 16#7c42_0fe9#, 16#f884_1ec9#, 16#0000_0000#,
      16#0980_8683#, 16#322b_ed48#, 16#1e11_70ac#, 16#6c5a_724e#,
      16#fd0e_fffb#, 16#0f85_3856#, 16#3dae_d51e#, 16#362d_3927#,
      16#0a0f_d964#, 16#685c_a621#, 16#9b5b_54d1#, 16#2436_2e3a#,
      16#0c0a_67b1#, 16#9357_e70f#, 16#b4ee_96d2#, 16#1b9b_919e#,
      16#80c0_c54f#, 16#61dc_20a2#, 16#5a77_4b69#, 16#1c12_1a16#,
      16#e293_ba0a#, 16#c0a0_2ae5#, 16#3c22_e043#, 16#121b_171d#,
      16#0e09_0d0b#, 16#f28b_c7ad#, 16#2db6_a8b9#, 16#141e_a9c8#,
      16#57f1_1985#, 16#af75_074c#, 16#ee99_ddbb#, 16#a37f_60fd#,
      16#f701_269f#, 16#5c72_f5bc#, 16#4466_3bc5#, 16#5bfb_7e34#,
      16#8b43_2976#, 16#cb23_c6dc#, 16#b6ed_fc68#, 16#b8e4_f163#,
      16#d731_dcca#, 16#4263_8510#, 16#1397_2240#, 16#84c6_1120#,
      16#854a_247d#, 16#d2bb_3df8#, 16#aef9_3211#, 16#c729_a16d#,
      16#1d9e_2f4b#, 16#dcb2_30f3#, 16#0d86_52ec#, 16#77c1_e3d0#,
      16#2bb3_166c#, 16#a970_b999#, 16#1194_48fa#, 16#47e9_6422#,
      16#a8fc_8cc4#, 16#a0f0_3f1a#, 16#567d_2cd8#, 16#2233_90ef#,
      16#8749_4ec7#, 16#d938_d1c1#, 16#8cca_a2fe#, 16#98d4_0b36#,
      16#a6f5_81cf#, 16#a57a_de28#, 16#dab7_8e26#, 16#3fad_bfa4#,
      16#2c3a_9de4#, 16#5078_920d#, 16#6a5f_cc9b#, 16#547e_4662#,
      16#f68d_13c2#, 16#90d8_b8e8#, 16#2e39_f75e#, 16#82c3_aff5#,
      16#9f5d_80be#, 16#69d0_937c#, 16#6fd5_2da9#, 16#cf25_12b3#,
      16#c8ac_993b#, 16#1018_7da7#, 16#e89c_636e#, 16#db3b_bb7b#,
      16#cd26_7809#, 16#6e59_18f4#, 16#ec9a_b701#, 16#834f_9aa8#,
      16#e695_6e65#, 16#aaff_e67e#, 16#21bc_cf08#, 16#ef15_e8e6#,
      16#bae7_9bd9#, 16#4a6f_36ce#, 16#ea9f_09d4#, 16#29b0_7cd6#,
      16#31a4_b2af#, 16#2a3f_2331#, 16#c6a5_9430#, 16#35a2_66c0#,
      16#744e_bc37#, 16#fc82_caa6#, 16#e090_d0b0#, 16#33a7_d815#,
      16#f104_984a#, 16#41ec_daf7#, 16#7fcd_500e#, 16#1791_f62f#,
      16#764d_d68d#, 16#43ef_b04d#, 16#ccaa_4d54#, 16#e496_04df#,
      16#9ed1_b5e3#, 16#4c6a_881b#, 16#c12c_1fb8#, 16#4665_517f#,
      16#9d5e_ea04#, 16#018c_355d#, 16#fa87_7473#, 16#fb0b_412e#,
      16#b367_1d5a#, 16#92db_d252#, 16#e910_5633#, 16#6dd6_4713#,
      16#9ad7_618c#, 16#37a1_0c7a#, 16#59f8_148e#, 16#eb13_3c89#,
      16#cea9_27ee#, 16#b761_c935#, 16#e11c_e5ed#, 16#7a47_b13c#,
      16#9cd2_df59#, 16#55f2_733f#, 16#1814_ce79#, 16#73c7_37bf#,
      16#53f7_cdea#, 16#5ffd_aa5b#, 16#df3d_6f14#, 16#7844_db86#,
      16#caaf_f381#, 16#b968_c43e#, 16#3824_342c#, 16#c2a3_405f#,
      16#161d_c372#, 16#bce2_250c#, 16#283c_498b#, 16#ff0d_9541#,
      16#39a8_0171#, 16#080c_b3de#, 16#d8b4_e49c#, 16#6456_c190#,
      16#7bcb_8461#, 16#d532_b670#, 16#486c_5c74#, 16#d0b8_5742#);

   Td1 : constant Sbox :=
     (16#5051_f4a7#, 16#537e_4165#, 16#c31a_17a4#, 16#963a_275e#,
      16#cb3b_ab6b#, 16#f11f_9d45#, 16#abac_fa58#, 16#934b_e303#,
      16#5520_30fa#, 16#f6ad_766d#, 16#9188_cc76#, 16#25f5_024c#,
      16#fc4f_e5d7#, 16#d7c5_2acb#, 16#8026_3544#, 16#8fb5_62a3#,
      16#49de_b15a#, 16#6725_ba1b#, 16#9845_ea0e#, 16#e15d_fec0#,
      16#02c3_2f75#, 16#1281_4cf0#, 16#a38d_4697#, 16#c66b_d3f9#,
      16#e703_8f5f#, 16#9515_929c#, 16#ebbf_6d7a#, 16#da95_5259#,
      16#2dd4_be83#, 16#d358_7421#, 16#2949_e069#, 16#448e_c9c8#,
      16#6a75_c289#, 16#78f4_8e79#, 16#6b99_583e#, 16#dd27_b971#,
      16#b6be_e14f#, 16#17f0_88ad#, 16#66c9_20ac#, 16#b47d_ce3a#,
      16#1863_df4a#, 16#82e5_1a31#, 16#6097_5133#, 16#4562_537f#,
      16#e0b1_6477#, 16#84bb_6bae#, 16#1cfe_81a0#, 16#94f9_082b#,
      16#5870_4868#, 16#198f_45fd#, 16#8794_de6c#, 16#b752_7bf8#,
      16#23ab_73d3#, 16#e272_4b02#, 16#57e3_1f8f#, 16#2a66_55ab#,
      16#07b2_eb28#, 16#032f_b5c2#, 16#9a86_c57b#, 16#a5d3_3708#,
      16#f230_2887#, 16#b223_bfa5#, 16#ba02_036a#, 16#5ced_1682#,
      16#2b8a_cf1c#, 16#92a7_79b4#, 16#f0f3_07f2#, 16#a14e_69e2#,
      16#cd65_daf4#, 16#d506_05be#, 16#1fd1_3462#, 16#8ac4_a6fe#,
      16#9d34_2e53#, 16#a0a2_f355#, 16#3205_8ae1#, 16#75a4_f6eb#,
      16#390b_83ec#, 16#aa40_60ef#, 16#065e_719f#, 16#51bd_6e10#,
      16#f93e_218a#, 16#3d96_dd06#, 16#aedd_3e05#, 16#464d_e6bd#,
      16#b591_548d#, 16#0571_c45d#, 16#6f04_06d4#, 16#ff60_5015#,
      16#2419_98fb#, 16#97d6_bde9#, 16#cc89_4043#, 16#7767_d99e#,
      16#bdb0_e842#, 16#8807_898b#, 16#38e7_195b#, 16#db79_c8ee#,
      16#47a1_7c0a#, 16#e97c_420f#, 16#c9f8_841e#, 16#0000_0000#,
      16#8309_8086#, 16#4832_2bed#, 16#ac1e_1170#, 16#4e6c_5a72#,
      16#fbfd_0eff#, 16#560f_8538#, 16#1e3d_aed5#, 16#2736_2d39#,
      16#640a_0fd9#, 16#2168_5ca6#, 16#d19b_5b54#, 16#3a24_362e#,
      16#b10c_0a67#, 16#0f93_57e7#, 16#d2b4_ee96#, 16#9e1b_9b91#,
      16#4f80_c0c5#, 16#a261_dc20#, 16#695a_774b#, 16#161c_121a#,
      16#0ae2_93ba#, 16#e5c0_a02a#, 16#433c_22e0#, 16#1d12_1b17#,
      16#0b0e_090d#, 16#adf2_8bc7#, 16#b92d_b6a8#, 16#c814_1ea9#,
      16#8557_f119#, 16#4caf_7507#, 16#bbee_99dd#, 16#fda3_7f60#,
      16#9ff7_0126#, 16#bc5c_72f5#, 16#c544_663b#, 16#345b_fb7e#,
      16#768b_4329#, 16#dccb_23c6#, 16#68b6_edfc#, 16#63b8_e4f1#,
      16#cad7_31dc#, 16#1042_6385#, 16#4013_9722#, 16#2084_c611#,
      16#7d85_4a24#, 16#f8d2_bb3d#, 16#11ae_f932#, 16#6dc7_29a1#,
      16#4b1d_9e2f#, 16#f3dc_b230#, 16#ec0d_8652#, 16#d077_c1e3#,
      16#6c2b_b316#, 16#99a9_70b9#, 16#fa11_9448#, 16#2247_e964#,
      16#c4a8_fc8c#, 16#1aa0_f03f#, 16#d856_7d2c#, 16#ef22_3390#,
      16#c787_494e#, 16#c1d9_38d1#, 16#fe8c_caa2#, 16#3698_d40b#,
      16#cfa6_f581#, 16#28a5_7ade#, 16#26da_b78e#, 16#a43f_adbf#,
      16#e42c_3a9d#, 16#0d50_7892#, 16#9b6a_5fcc#, 16#6254_7e46#,
      16#c2f6_8d13#, 16#e890_d8b8#, 16#5e2e_39f7#, 16#f582_c3af#,
      16#be9f_5d80#, 16#7c69_d093#, 16#a96f_d52d#, 16#b3cf_2512#,
      16#3bc8_ac99#, 16#a710_187d#, 16#6ee8_9c63#, 16#7bdb_3bbb#,
      16#09cd_2678#, 16#f46e_5918#, 16#01ec_9ab7#, 16#a883_4f9a#,
      16#65e6_956e#, 16#7eaa_ffe6#, 16#0821_bccf#, 16#e6ef_15e8#,
      16#d9ba_e79b#, 16#ce4a_6f36#, 16#d4ea_9f09#, 16#d629_b07c#,
      16#af31_a4b2#, 16#312a_3f23#, 16#30c6_a594#, 16#c035_a266#,
      16#3774_4ebc#, 16#a6fc_82ca#, 16#b0e0_90d0#, 16#1533_a7d8#,
      16#4af1_0498#, 16#f741_ecda#, 16#0e7f_cd50#, 16#2f17_91f6#,
      16#8d76_4dd6#, 16#4d43_efb0#, 16#54cc_aa4d#, 16#dfe4_9604#,
      16#e39e_d1b5#, 16#1b4c_6a88#, 16#b8c1_2c1f#, 16#7f46_6551#,
      16#049d_5eea#, 16#5d01_8c35#, 16#73fa_8774#, 16#2efb_0b41#,
      16#5ab3_671d#, 16#5292_dbd2#, 16#33e9_1056#, 16#136d_d647#,
      16#8c9a_d761#, 16#7a37_a10c#, 16#8e59_f814#, 16#89eb_133c#,
      16#eece_a927#, 16#35b7_61c9#, 16#ede1_1ce5#, 16#3c7a_47b1#,
      16#599c_d2df#, 16#3f55_f273#, 16#7918_14ce#, 16#bf73_c737#,
      16#ea53_f7cd#, 16#5b5f_fdaa#, 16#14df_3d6f#, 16#8678_44db#,
      16#81ca_aff3#, 16#3eb9_68c4#, 16#2c38_2434#, 16#5fc2_a340#,
      16#7216_1dc3#, 16#0cbc_e225#, 16#8b28_3c49#, 16#41ff_0d95#,
      16#7139_a801#, 16#de08_0cb3#, 16#9cd8_b4e4#, 16#9064_56c1#,
      16#617b_cb84#, 16#70d5_32b6#, 16#7448_6c5c#, 16#42d0_b857#);

   Td2 : constant Sbox :=
     (16#a750_51f4#, 16#6553_7e41#, 16#a4c3_1a17#, 16#5e96_3a27#,
      16#6bcb_3bab#, 16#45f1_1f9d#, 16#58ab_acfa#, 16#0393_4be3#,
      16#fa55_2030#, 16#6df6_ad76#, 16#7691_88cc#, 16#4c25_f502#,
      16#d7fc_4fe5#, 16#cbd7_c52a#, 16#4480_2635#, 16#a38f_b562#,
      16#5a49_deb1#, 16#1b67_25ba#, 16#0e98_45ea#, 16#c0e1_5dfe#,
      16#7502_c32f#, 16#f012_814c#, 16#97a3_8d46#, 16#f9c6_6bd3#,
      16#5fe7_038f#, 16#9c95_1592#, 16#7aeb_bf6d#, 16#59da_9552#,
      16#832d_d4be#, 16#21d3_5874#, 16#6929_49e0#, 16#c844_8ec9#,
      16#896a_75c2#, 16#7978_f48e#, 16#3e6b_9958#, 16#71dd_27b9#,
      16#4fb6_bee1#, 16#ad17_f088#, 16#ac66_c920#, 16#3ab4_7dce#,
      16#4a18_63df#, 16#3182_e51a#, 16#3360_9751#, 16#7f45_6253#,
      16#77e0_b164#, 16#ae84_bb6b#, 16#a01c_fe81#, 16#2b94_f908#,
      16#6858_7048#, 16#fd19_8f45#, 16#6c87_94de#, 16#f8b7_527b#,
      16#d323_ab73#, 16#02e2_724b#, 16#8f57_e31f#, 16#ab2a_6655#,
      16#2807_b2eb#, 16#c203_2fb5#, 16#7b9a_86c5#, 16#08a5_d337#,
      16#87f2_3028#, 16#a5b2_23bf#, 16#6aba_0203#, 16#825c_ed16#,
      16#1c2b_8acf#, 16#b492_a779#, 16#f2f0_f307#, 16#e2a1_4e69#,
      16#f4cd_65da#, 16#bed5_0605#, 16#621f_d134#, 16#fe8a_c4a6#,
      16#539d_342e#, 16#55a0_a2f3#, 16#e132_058a#, 16#eb75_a4f6#,
      16#ec39_0b83#, 16#efaa_4060#, 16#9f06_5e71#, 16#1051_bd6e#,
      16#8af9_3e21#, 16#063d_96dd#, 16#05ae_dd3e#, 16#bd46_4de6#,
      16#8db5_9154#, 16#5d05_71c4#, 16#d46f_0406#, 16#15ff_6050#,
      16#fb24_1998#, 16#e997_d6bd#, 16#43cc_8940#, 16#9e77_67d9#,
      16#42bd_b0e8#, 16#8b88_0789#, 16#5b38_e719#, 16#eedb_79c8#,
      16#0a47_a17c#, 16#0fe9_7c42#, 16#1ec9_f884#, 16#0000_0000#,
      16#8683_0980#, 16#ed48_322b#, 16#70ac_1e11#, 16#724e_6c5a#,
      16#fffb_fd0e#, 16#3856_0f85#, 16#d51e_3dae#, 16#3927_362d#,
      16#d964_0a0f#, 16#a621_685c#, 16#54d1_9b5b#, 16#2e3a_2436#,
      16#67b1_0c0a#, 16#e70f_9357#, 16#96d2_b4ee#, 16#919e_1b9b#,
      16#c54f_80c0#, 16#20a2_61dc#, 16#4b69_5a77#, 16#1a16_1c12#,
      16#ba0a_e293#, 16#2ae5_c0a0#, 16#e043_3c22#, 16#171d_121b#,
      16#0d0b_0e09#, 16#c7ad_f28b#, 16#a8b9_2db6#, 16#a9c8_141e#,
      16#1985_57f1#, 16#074c_af75#, 16#ddbb_ee99#, 16#60fd_a37f#,
      16#269f_f701#, 16#f5bc_5c72#, 16#3bc5_4466#, 16#7e34_5bfb#,
      16#2976_8b43#, 16#c6dc_cb23#, 16#fc68_b6ed#, 16#f163_b8e4#,
      16#dcca_d731#, 16#8510_4263#, 16#2240_1397#, 16#1120_84c6#,
      16#247d_854a#, 16#3df8_d2bb#, 16#3211_aef9#, 16#a16d_c729#,
      16#2f4b_1d9e#, 16#30f3_dcb2#, 16#52ec_0d86#, 16#e3d0_77c1#,
      16#166c_2bb3#, 16#b999_a970#, 16#48fa_1194#, 16#6422_47e9#,
      16#8cc4_a8fc#, 16#3f1a_a0f0#, 16#2cd8_567d#, 16#90ef_2233#,
      16#4ec7_8749#, 16#d1c1_d938#, 16#a2fe_8cca#, 16#0b36_98d4#,
      16#81cf_a6f5#, 16#de28_a57a#, 16#8e26_dab7#, 16#bfa4_3fad#,
      16#9de4_2c3a#, 16#920d_5078#, 16#cc9b_6a5f#, 16#4662_547e#,
      16#13c2_f68d#, 16#b8e8_90d8#, 16#f75e_2e39#, 16#aff5_82c3#,
      16#80be_9f5d#, 16#937c_69d0#, 16#2da9_6fd5#, 16#12b3_cf25#,
      16#993b_c8ac#, 16#7da7_1018#, 16#636e_e89c#, 16#bb7b_db3b#,
      16#7809_cd26#, 16#18f4_6e59#, 16#b701_ec9a#, 16#9aa8_834f#,
      16#6e65_e695#, 16#e67e_aaff#, 16#cf08_21bc#, 16#e8e6_ef15#,
      16#9bd9_bae7#, 16#36ce_4a6f#, 16#09d4_ea9f#, 16#7cd6_29b0#,
      16#b2af_31a4#, 16#2331_2a3f#, 16#9430_c6a5#, 16#66c0_35a2#,
      16#bc37_744e#, 16#caa6_fc82#, 16#d0b0_e090#, 16#d815_33a7#,
      16#984a_f104#, 16#daf7_41ec#, 16#500e_7fcd#, 16#f62f_1791#,
      16#d68d_764d#, 16#b04d_43ef#, 16#4d54_ccaa#, 16#04df_e496#,
      16#b5e3_9ed1#, 16#881b_4c6a#, 16#1fb8_c12c#, 16#517f_4665#,
      16#ea04_9d5e#, 16#355d_018c#, 16#7473_fa87#, 16#412e_fb0b#,
      16#1d5a_b367#, 16#d252_92db#, 16#5633_e910#, 16#4713_6dd6#,
      16#618c_9ad7#, 16#0c7a_37a1#, 16#148e_59f8#, 16#3c89_eb13#,
      16#27ee_cea9#, 16#c935_b761#, 16#e5ed_e11c#, 16#b13c_7a47#,
      16#df59_9cd2#, 16#733f_55f2#, 16#ce79_1814#, 16#37bf_73c7#,
      16#cdea_53f7#, 16#aa5b_5ffd#, 16#6f14_df3d#, 16#db86_7844#,
      16#f381_caaf#, 16#c43e_b968#, 16#342c_3824#, 16#405f_c2a3#,
      16#c372_161d#, 16#250c_bce2#, 16#498b_283c#, 16#9541_ff0d#,
      16#0171_39a8#, 16#b3de_080c#, 16#e49c_d8b4#, 16#c190_6456#,
      16#8461_7bcb#, 16#b670_d532#, 16#5c74_486c#, 16#5742_d0b8#);

   Td3 : constant Sbox :=
     (16#f4a7_5051#, 16#4165_537e#, 16#17a4_c31a#, 16#275e_963a#,
      16#ab6b_cb3b#, 16#9d45_f11f#, 16#fa58_abac#, 16#e303_934b#,
      16#30fa_5520#, 16#766d_f6ad#, 16#cc76_9188#, 16#024c_25f5#,
      16#e5d7_fc4f#, 16#2acb_d7c5#, 16#3544_8026#, 16#62a3_8fb5#,
      16#b15a_49de#, 16#ba1b_6725#, 16#ea0e_9845#, 16#fec0_e15d#,
      16#2f75_02c3#, 16#4cf0_1281#, 16#4697_a38d#, 16#d3f9_c66b#,
      16#8f5f_e703#, 16#929c_9515#, 16#6d7a_ebbf#, 16#5259_da95#,
      16#be83_2dd4#, 16#7421_d358#, 16#e069_2949#, 16#c9c8_448e#,
      16#c289_6a75#, 16#8e79_78f4#, 16#583e_6b99#, 16#b971_dd27#,
      16#e14f_b6be#, 16#88ad_17f0#, 16#20ac_66c9#, 16#ce3a_b47d#,
      16#df4a_1863#, 16#1a31_82e5#, 16#5133_6097#, 16#537f_4562#,
      16#6477_e0b1#, 16#6bae_84bb#, 16#81a0_1cfe#, 16#082b_94f9#,
      16#4868_5870#, 16#45fd_198f#, 16#de6c_8794#, 16#7bf8_b752#,
      16#73d3_23ab#, 16#4b02_e272#, 16#1f8f_57e3#, 16#55ab_2a66#,
      16#eb28_07b2#, 16#b5c2_032f#, 16#c57b_9a86#, 16#3708_a5d3#,
      16#2887_f230#, 16#bfa5_b223#, 16#036a_ba02#, 16#1682_5ced#,
      16#cf1c_2b8a#, 16#79b4_92a7#, 16#07f2_f0f3#, 16#69e2_a14e#,
      16#daf4_cd65#, 16#05be_d506#, 16#3462_1fd1#, 16#a6fe_8ac4#,
      16#2e53_9d34#, 16#f355_a0a2#, 16#8ae1_3205#, 16#f6eb_75a4#,
      16#83ec_390b#, 16#60ef_aa40#, 16#719f_065e#, 16#6e10_51bd#,
      16#218a_f93e#, 16#dd06_3d96#, 16#3e05_aedd#, 16#e6bd_464d#,
      16#548d_b591#, 16#c45d_0571#, 16#06d4_6f04#, 16#5015_ff60#,
      16#98fb_2419#, 16#bde9_97d6#, 16#4043_cc89#, 16#d99e_7767#,
      16#e842_bdb0#, 16#898b_8807#, 16#195b_38e7#, 16#c8ee_db79#,
      16#7c0a_47a1#, 16#420f_e97c#, 16#841e_c9f8#, 16#0000_0000#,
      16#8086_8309#, 16#2bed_4832#, 16#1170_ac1e#, 16#5a72_4e6c#,
      16#0eff_fbfd#, 16#8538_560f#, 16#aed5_1e3d#, 16#2d39_2736#,
      16#0fd9_640a#, 16#5ca6_2168#, 16#5b54_d19b#, 16#362e_3a24#,
      16#0a67_b10c#, 16#57e7_0f93#, 16#ee96_d2b4#, 16#9b91_9e1b#,
      16#c0c5_4f80#, 16#dc20_a261#, 16#774b_695a#, 16#121a_161c#,
      16#93ba_0ae2#, 16#a02a_e5c0#, 16#22e0_433c#, 16#1b17_1d12#,
      16#090d_0b0e#, 16#8bc7_adf2#, 16#b6a8_b92d#, 16#1ea9_c814#,
      16#f119_8557#, 16#7507_4caf#, 16#99dd_bbee#, 16#7f60_fda3#,
      16#0126_9ff7#, 16#72f5_bc5c#, 16#663b_c544#, 16#fb7e_345b#,
      16#4329_768b#, 16#23c6_dccb#, 16#edfc_68b6#, 16#e4f1_63b8#,
      16#31dc_cad7#, 16#6385_1042#, 16#9722_4013#, 16#c611_2084#,
      16#4a24_7d85#, 16#bb3d_f8d2#, 16#f932_11ae#, 16#29a1_6dc7#,
      16#9e2f_4b1d#, 16#b230_f3dc#, 16#8652_ec0d#, 16#c1e3_d077#,
      16#b316_6c2b#, 16#70b9_99a9#, 16#9448_fa11#, 16#e964_2247#,
      16#fc8c_c4a8#, 16#f03f_1aa0#, 16#7d2c_d856#, 16#3390_ef22#,
      16#494e_c787#, 16#38d1_c1d9#, 16#caa2_fe8c#, 16#d40b_3698#,
      16#f581_cfa6#, 16#7ade_28a5#, 16#b78e_26da#, 16#adbf_a43f#,
      16#3a9d_e42c#, 16#7892_0d50#, 16#5fcc_9b6a#, 16#7e46_6254#,
      16#8d13_c2f6#, 16#d8b8_e890#, 16#39f7_5e2e#, 16#c3af_f582#,
      16#5d80_be9f#, 16#d093_7c69#, 16#d52d_a96f#, 16#2512_b3cf#,
      16#ac99_3bc8#, 16#187d_a710#, 16#9c63_6ee8#, 16#3bbb_7bdb#,
      16#2678_09cd#, 16#5918_f46e#, 16#9ab7_01ec#, 16#4f9a_a883#,
      16#956e_65e6#, 16#ffe6_7eaa#, 16#bccf_0821#, 16#15e8_e6ef#,
      16#e79b_d9ba#, 16#6f36_ce4a#, 16#9f09_d4ea#, 16#b07c_d629#,
      16#a4b2_af31#, 16#3f23_312a#, 16#a594_30c6#, 16#a266_c035#,
      16#4ebc_3774#, 16#82ca_a6fc#, 16#90d0_b0e0#, 16#a7d8_1533#,
      16#0498_4af1#, 16#ecda_f741#, 16#cd50_0e7f#, 16#91f6_2f17#,
      16#4dd6_8d76#, 16#efb0_4d43#, 16#aa4d_54cc#, 16#9604_dfe4#,
      16#d1b5_e39e#, 16#6a88_1b4c#, 16#2c1f_b8c1#, 16#6551_7f46#,
      16#5eea_049d#, 16#8c35_5d01#, 16#8774_73fa#, 16#0b41_2efb#,
      16#671d_5ab3#, 16#dbd2_5292#, 16#1056_33e9#, 16#d647_136d#,
      16#d761_8c9a#, 16#a10c_7a37#, 16#f814_8e59#, 16#133c_89eb#,
      16#a927_eece#, 16#61c9_35b7#, 16#1ce5_ede1#, 16#47b1_3c7a#,
      16#d2df_599c#, 16#f273_3f55#, 16#14ce_7918#, 16#c737_bf73#,
      16#f7cd_ea53#, 16#fdaa_5b5f#, 16#3d6f_14df#, 16#44db_8678#,
      16#aff3_81ca#, 16#68c4_3eb9#, 16#2434_2c38#, 16#a340_5fc2#,
      16#1dc3_7216#, 16#e225_0cbc#, 16#3c49_8b28#, 16#0d95_41ff#,
      16#a801_7139#, 16#0cb3_de08#, 16#b4e4_9cd8#, 16#56c1_9064#,
      16#cb84_617b#, 16#32b6_70d5#, 16#6c5c_7448#, 16#b857_42d0#);

   Td4 : constant Final_Sbox :=
     (16#52#, 16#09#, 16#6a#, 16#d5#, 16#30#, 16#36#, 16#a5#, 16#38#, 16#bf#,
      16#40#, 16#a3#, 16#9e#, 16#81#, 16#f3#, 16#d7#, 16#fb#, 16#7c#, 16#e3#,
      16#39#, 16#82#, 16#9b#, 16#2f#, 16#ff#, 16#87#, 16#34#, 16#8e#, 16#43#,
      16#44#, 16#c4#, 16#de#, 16#e9#, 16#cb#, 16#54#, 16#7b#, 16#94#, 16#32#,
      16#a6#, 16#c2#, 16#23#, 16#3d#, 16#ee#, 16#4c#, 16#95#, 16#0b#, 16#42#,
      16#fa#, 16#c3#, 16#4e#, 16#08#, 16#2e#, 16#a1#, 16#66#, 16#28#, 16#d9#,
      16#24#, 16#b2#, 16#76#, 16#5b#, 16#a2#, 16#49#, 16#6d#, 16#8b#, 16#d1#,
      16#25#, 16#72#, 16#f8#, 16#f6#, 16#64#, 16#86#, 16#68#, 16#98#, 16#16#,
      16#d4#, 16#a4#, 16#5c#, 16#cc#, 16#5d#, 16#65#, 16#b6#, 16#92#, 16#6c#,
      16#70#, 16#48#, 16#50#, 16#fd#, 16#ed#, 16#b9#, 16#da#, 16#5e#, 16#15#,
      16#46#, 16#57#, 16#a7#, 16#8d#, 16#9d#, 16#84#, 16#90#, 16#d8#, 16#ab#,
      16#00#, 16#8c#, 16#bc#, 16#d3#, 16#0a#, 16#f7#, 16#e4#, 16#58#, 16#05#,
      16#b8#, 16#b3#, 16#45#, 16#06#, 16#d0#, 16#2c#, 16#1e#, 16#8f#, 16#ca#,
      16#3f#, 16#0f#, 16#02#, 16#c1#, 16#af#, 16#bd#, 16#03#, 16#01#, 16#13#,
      16#8a#, 16#6b#, 16#3a#, 16#91#, 16#11#, 16#41#, 16#4f#, 16#67#, 16#dc#,
      16#ea#, 16#97#, 16#f2#, 16#cf#, 16#ce#, 16#f0#, 16#b4#, 16#e6#, 16#73#,
      16#96#, 16#ac#, 16#74#, 16#22#, 16#e7#, 16#ad#, 16#35#, 16#85#, 16#e2#,
      16#f9#, 16#37#, 16#e8#, 16#1c#, 16#75#, 16#df#, 16#6e#, 16#47#, 16#f1#,
      16#1a#, 16#71#, 16#1d#, 16#29#, 16#c5#, 16#89#, 16#6f#, 16#b7#, 16#62#,
      16#0e#, 16#aa#, 16#18#, 16#be#, 16#1b#, 16#fc#, 16#56#, 16#3e#, 16#4b#,
      16#c6#, 16#d2#, 16#79#, 16#20#, 16#9a#, 16#db#, 16#c0#, 16#fe#, 16#78#,
      16#cd#, 16#5a#, 16#f4#, 16#1f#, 16#dd#, 16#a8#, 16#33#, 16#88#, 16#07#,
      16#c7#, 16#31#, 16#b1#, 16#12#, 16#10#, 16#59#, 16#27#, 16#80#, 16#ec#,
      16#5f#, 16#60#, 16#51#, 16#7f#, 16#a9#, 16#19#, 16#b5#, 16#4a#, 16#0d#,
      16#2d#, 16#e5#, 16#7a#, 16#9f#, 16#93#, 16#c9#, 16#9c#, 16#ef#, 16#a0#,
      16#e0#, 16#3b#, 16#4d#, 16#ae#, 16#2a#, 16#f5#, 16#b0#, 16#c8#, 16#eb#,
      16#bb#, 16#3c#, 16#83#, 16#53#, 16#99#, 16#61#, 16#17#, 16#2b#, 16#04#,
      16#7e#, 16#ba#, 16#77#, 16#d6#, 16#26#, 16#e1#, 16#69#, 16#14#, 16#63#,
      16#55#, 16#21#, 16#0c#, 16#7d#);

   --  for 128-bit blocks, Rijndael never uses more than 10 rcon values
   Rcon : constant Key_Sbox :=
     (16#0100_0000#, 16#0200_0000#, 16#0400_0000#, 16#0800_0000#,
      16#1000_0000#, 16#2000_0000#, 16#4000_0000#, 16#8000_0000#,
      16#1B00_0000#, 16#3600_0000#);

   function To_Unsigned_32
     (Data : in Stream_Element_Array; Offset : in Stream_Element_Offset)
      return Unsigned_32
   is
   begin
      Ada.Text_IO.Put_Line ("Offset: " & Offset'Image);
      Ada.Text_IO.Put_Line ("Data last: " & Data'Last'Image);
      return
        Shift_Left (Unsigned_32 (Data (Offset)), 24) or
        Shift_Left (Unsigned_32 (Data (Offset + 1)), 16) or
        Shift_Left (Unsigned_32 (Data (Offset + 2)), 8) or
        Unsigned_32 (Data (Offset + 3));
   exception
      when Constraint_Error =>
         Ada.Text_IO.Put_Line
           (Ada.Text_IO.Standard_Error, "Constraint error in To_Unsigned_32");
         raise;
   end To_Unsigned_32;

   procedure Put_Unsigned_32
     (Data   : in out Stream_Element_Array; Value : in Unsigned_32;
      Offset : in     Stream_Element_Offset)
   is
   begin
      Data (Offset)     := Stream_Element (Shift_Right (Value, 24));
      Data (Offset + 1) :=
        Stream_Element (Shift_Right (Value, 16) and 16#0ff#);
      Data (Offset + 2) := Stream_Element (Shift_Right (Value, 8) and 16#0ff#);
      Data (Offset + 3) := Stream_Element (Value and 16#0ff#);
   end Put_Unsigned_32;

   procedure Set_Encrypt_Key (Key : out Key_Type; Data : in Secret_Key) is
      Temp : Unsigned_32;
      N    : Natural := 0;
      I    : Natural := 0;
      pragma Style_Checks ("-mr");
   begin
      Key.Key (0) := To_Unsigned_32 (Data.Secret, Data.Secret'First + 0);
      Key.Key (1) := To_Unsigned_32 (Data.Secret, Data.Secret'First + 4);
      Key.Key (2) := To_Unsigned_32 (Data.Secret, Data.Secret'First + 8);
      Key.Key (3) := To_Unsigned_32 (Data.Secret, Data.Secret'First + 12);
      if Data.Length = 128 / 8 then
         Key.Rounds := 10;
         loop
            Temp            := Key.Key (N + 3);
            Key.Key (N + 4) :=
              Key.Key (N + 0) xor
              (Te4 (Shift_Right (Temp, 16) and 16#0ff#) and 16#ff00_0000#) xor
              (Te4 (Shift_Right (Temp, 8) and 16#0ff#) and 16#00ff_0000#) xor
              (Te4 (Temp and 16#0ff#) and 16#0000_ff00#) xor
              (Te4 (Shift_Right (Temp, 24) and 16#0ff#) and 16#00ff#) xor
              Rcon (I);
            Key.Key (N + 5) := Key.Key (N + 1) xor Key.Key (N + 4);
            Key.Key (N + 6) := Key.Key (N + 2) xor Key.Key (N + 5);
            Key.Key (N + 7) := Key.Key (N + 3) xor Key.Key (N + 6);
            I               := I + 1;
            exit when I = 10;
            N := N + 4;
         end loop;
         return;
      end if;
      Key.Key (4) := To_Unsigned_32 (Data.Secret, Data.Secret'First + 16);
      Key.Key (5) := To_Unsigned_32 (Data.Secret, Data.Secret'First + 20);
      if Data.Length = 192 / 8 then
         Key.Rounds := 12;
         loop
            Temp            := Key.Key (N + 5);
            Key.Key (N + 6) :=
              Key.Key (N + 0) xor
              (Te4 (Shift_Right (Temp, 16) and 16#0ff#) and 16#ff00_0000#) xor
              (Te4 (Shift_Right (Temp, 8) and 16#0ff#) and 16#00ff_0000#) xor
              (Te4 (Temp and 16#0ff#) and 16#0000_ff00#) xor
              (Te4 (Shift_Right (Temp, 24) and 16#0ff#) and 16#00ff#) xor
              Rcon (I);
            Key.Key (N + 7) := Key.Key (N + 1) xor Key.Key (N + 6);
            Key.Key (N + 8) := Key.Key (N + 2) xor Key.Key (N + 7);
            Key.Key (N + 9) := Key.Key (N + 3) xor Key.Key (N + 8);
            I               := I + 1;
            exit when I = 8;
            Key.Key (N + 10) := Key.Key (N + 4) xor Key.Key (N + 9);
            Key.Key (N + 11) := Key.Key (N + 5) xor Key.Key (N + 10);
            N                := N + 6;
         end loop;
         return;
      end if;
      Key.Key (6) := To_Unsigned_32 (Data.Secret, Data.Secret'First + 24);
      Key.Key (7) := To_Unsigned_32 (Data.Secret, Data.Secret'First + 28);
      if Data.Length = 256 / 8 then
         Key.Rounds := 14;
         loop
            Temp             := Key.Key (N + 7);
            Key.Key (N + 8)  :=
              Key.Key (N + 0) xor
              (Te4 (Shift_Right (Temp, 16) and 16#0ff#) and 16#ff00_0000#) xor
              (Te4 (Shift_Right (Temp, 8) and 16#0ff#) and 16#00ff_0000#) xor
              (Te4 (Temp and 16#0ff#) and 16#0000_ff00#) xor
              (Te4 (Shift_Right (Temp, 24) and 16#0ff#) and 16#00ff#) xor
              Rcon (I);
            Key.Key (N + 8)  := Key.Key (N + 0);
            Key.Key (N + 8)  :=
              Key.Key (N + 8) xor
              (Te4 (Shift_Right (Temp, 16) and 16#0ff#) and 16#ff00_0000#);
            Key.Key (N + 8)  :=
              Key.Key (N + 8) xor
              (Te4 (Shift_Right (Temp, 8) and 16#0ff#) and 16#00ff_0000#);
            Key.Key (N + 8)  :=
              Key.Key (N + 8) xor (Te4 (Temp and 16#0ff#) and 16#0000_ff00#);
            Key.Key (N + 8)  :=
              Key.Key (N + 8) xor
              (Te4 (Shift_Right (Temp, 24) and 16#0ff#) and 16#00ff#);
            Key.Key (N + 8)  := Key.Key (N + 8) xor Rcon (I);
            Key.Key (N + 9)  := Key.Key (N + 1) xor Key.Key (N + 8);
            Key.Key (N + 10) := Key.Key (N + 2) xor Key.Key (N + 9);
            Key.Key (N + 11) := Key.Key (N + 3) xor Key.Key (N + 10);
            I                := I + 1;
            exit when I = 7;

            Temp             := Key.Key (N + 11);
            Key.Key (N + 12) :=
              Key.Key (N + 4) xor
              (Te4 (Shift_Right (Temp, 24) and 16#0ff#) and 16#ff00_0000#) xor
              (Te4 (Shift_Right (Temp, 16) and 16#0ff#) and 16#00ff_0000#) xor
              (Te4 (Shift_Right (Temp, 8) and 16#0ff#) and 16#0000_ff00#) xor
              (Te4 (Temp and 16#0ff#) and 16#00ff#);
            Key.Key (N + 13) := Key.Key (N + 5) xor Key.Key (N + 12);
            Key.Key (N + 14) := Key.Key (N + 6) xor Key.Key (N + 13);
            Key.Key (N + 15) := Key.Key (N + 7) xor Key.Key (N + 14);
            N                := N + 8;
         end loop;
         return;
      end if;
   end Set_Encrypt_Key;

   procedure Swap (A, B : in out Unsigned_32);

   procedure Swap (A, B : in out Unsigned_32) is
      Temp : constant Unsigned_32 := A;
   begin
      A := B;
      B := Temp;
   end Swap;

   procedure Set_Decrypt_Key (Key : out Key_Type; Data : in Secret_Key) is
      I    : Natural := 0;
      J    : Natural := 0;
      Last : Natural;
   begin
      Set_Encrypt_Key (Key, Data);
      Last := 4 * Key.Rounds;
      J    := Last;
      while I < J loop
         Swap (Key.Key (I), Key.Key (J));
         Swap (Key.Key (I + 1), Key.Key (J + 1));
         Swap (Key.Key (I + 2), Key.Key (J + 2));
         Swap (Key.Key (I + 3), Key.Key (J + 3));
         I := I + 4;
         J := J - 4;
      end loop;
      I := 4;
      while I <= Last - 4 loop
         Key.Key (I) :=
           Td0
             (Te4 (Shift_Right (Key.Key (I), 24) and 16#0ff#) and 16#0ff#) xor
           Td1
             (Te4 (Shift_Right (Key.Key (I), 16) and 16#0ff#) and 16#0ff#) xor
           Td2 (Te4 (Shift_Right (Key.Key (I), 8) and 16#0ff#) and 16#0ff#) xor
           Td3 (Te4 (Key.Key (I) and 16#0ff#) and 16#0ff#);

         Key.Key (I + 1) :=
           Td0
             (Te4 (Shift_Right (Key.Key (I + 1), 24) and 16#0ff#) and
              16#0ff#) xor
           Td1
             (Te4 (Shift_Right (Key.Key (I + 1), 16) and 16#0ff#) and
              16#0ff#) xor
           Td2
             (Te4 (Shift_Right (Key.Key (I + 1), 8) and 16#0ff#) and
              16#0ff#) xor
           Td3 (Te4 (Key.Key (I + 1) and 16#0ff#) and 16#0ff#);

         Key.Key (I + 2) :=
           Td0
             (Te4 (Shift_Right (Key.Key (I + 2), 24) and 16#0ff#) and
              16#0ff#) xor
           Td1
             (Te4 (Shift_Right (Key.Key (I + 2), 16) and 16#0ff#) and
              16#0ff#) xor
           Td2
             (Te4 (Shift_Right (Key.Key (I + 2), 8) and 16#0ff#) and
              16#0ff#) xor
           Td3 (Te4 (Key.Key (I + 2) and 16#0ff#) and 16#0ff#);

         Key.Key (I + 3) :=
           Td0
             (Te4 (Shift_Right (Key.Key (I + 3), 24) and 16#0ff#) and
              16#0ff#) xor
           Td1
             (Te4 (Shift_Right (Key.Key (I + 3), 16) and 16#0ff#) and
              16#0ff#) xor
           Td2
             (Te4 (Shift_Right (Key.Key (I + 3), 8) and 16#0ff#) and
              16#0ff#) xor
           Td3 (Te4 (Key.Key (I + 3) and 16#0ff#) and 16#0ff#);

         I := I + 4;
      end loop;
   end Set_Decrypt_Key;

   --  ------------------------------
   --  Set the encryption initialization vector before starting the encryption.
   --  ------------------------------
   procedure Set_IV (E : in out Cipher; IV : in Word_Block_Type) is
   begin
      E.IV := IV;
   end Set_IV;

   procedure Set_IV (E : in out Cipher; Key : in Secret_Key) is
      Pos : Stream_Element_Offset := Key.Secret'First;
   begin
      for I in E.IV'Range loop
         E.IV (I) := To_Unsigned_32 (Key.Secret, Pos);
         Pos      := Pos + 4;
      end loop;
   end Set_IV;

   procedure Set_IV
     (E : in out Cipher; Key : in Secret_Key; IV : in Word_Block_Type)
   is
      Pos : Stream_Element_Offset := Key.Secret'First;
   begin
      E.IV := IV;
      for I in E.IV'Range loop
         exit when Pos + 3 > Key.Secret'Last;
         E.IV (I) := E.IV (I) xor To_Unsigned_32 (Key.Secret, Pos);
         Pos      := Pos + 4;
      end loop;
   end Set_IV;

   --  ------------------------------
   --  Set the padding.
   --  ------------------------------
   procedure Set_Padding (E : in out Cipher; Padding : in AES_Padding) is
   begin
      E.Padding := Padding;
   end Set_Padding;

   --  ------------------------------
   --  Get the padding used.
   --  ------------------------------
   function Padding (E : in Cipher) return AES_Padding is
   begin
      return E.Padding;
   end Padding;

   --  ------------------------------
   --  Return true if the cipher has a encryption/decryption key configured.
   --  ------------------------------
   function Has_Key (E : in Cipher) return Boolean is
   begin
      return E.Key.Rounds > 0;
   end Has_Key;

   overriding procedure Finalize (Object : in out Cipher) is
   begin
      Object.Key.Key := (others => 0);
      Object.IV      := (others => 0);
      Object.Data    := (others => 0);
   end Finalize;

   --  ------------------------------
   --  Set the encryption key to use.
   --  ------------------------------
   procedure Set_Key
     (E : in out Encoder; Data : in Secret_Key; Mode : in AES_Mode := CBC)
   is
   begin
      Set_Encrypt_Key (E.Key, Data);
      E.Mode := Mode;
   end Set_Key;

   --  ------------------------------
   --  Encodes the binary input stream represented by <b>Data</b> into
   --  an SHA-1 hash output stream <b>Into</b>.
   --
   --  If the transformer does not have enough room to write the result,
   --  it must return in <b>Encoded</b> the index of the last encoded
   --  position in the <b>Data</b> stream.
   --
   --  The transformer returns in <b>Last</b> the last valid position
   --  in the output stream <b>Into</b>.
   --
   --  The <b>Encoding_Error</b> exception is raised if the input
   --  stream cannot be transformed.
   --  ------------------------------
   overriding procedure Transform
     (E       : in out Encoder; Data : in Ada.Streams.Stream_Element_Array;
      Into    :    out Ada.Streams.Stream_Element_Array;
      Last    :    out Ada.Streams.Stream_Element_Offset;
      Encoded :    out Ada.Streams.Stream_Element_Offset)
   is
      Pos        : Ada.Streams.Stream_Element_Offset := Data'First;
      R          : Word_Block_Type;
      Pos_Limit  : Ada.Streams.Stream_Element_Offset;
      Last_Limit : Ada.Streams.Stream_Element_Offset;
   begin
      Last := Into'First;
      if E.Data_Count > 0 then
         while E.Data_Count < E.Data'Last loop
            E.Data_Count          := E.Data_Count + 1;
            E.Data (E.Data_Count) := Data (Pos);
            Pos                   := Pos + 1;
            exit when E.Data_Count = E.Data'Last;
            if Pos > Data'Last then
               Encoded := Data'Last;
               return;
            end if;
         end loop;

         --  Encrypt current block.
         case E.Mode is
            when ECB =>
               Encrypt
                 (E.Data, Into (Last .. Last + Block_Type'Length - 1), E.Key);

            when CBC =>
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First);
               E.IV (2) :=
                 E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4);
               E.IV (3) :=
                 E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8);
               E.IV (4) :=
                 E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12);
               Encrypt (E.IV, E.Key);
               Put_Unsigned_32 (Into, E.IV (1), Last);
               Put_Unsigned_32 (Into, E.IV (2), Last + 4);
               Put_Unsigned_32 (Into, E.IV (3), Last + 8);
               Put_Unsigned_32 (Into, E.IV (4), Last + 12);

            when PCBC =>
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First);
               E.IV (2) :=
                 E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4);
               E.IV (3) :=
                 E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8);
               E.IV (4) :=
                 E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12);
               Encrypt (E.IV, E.Key);
               Put_Unsigned_32 (Into, E.IV (1), Last);
               Put_Unsigned_32 (Into, E.IV (2), Last + 4);
               Put_Unsigned_32 (Into, E.IV (3), Last + 8);
               Put_Unsigned_32 (Into, E.IV (4), Last + 12);
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First);
               E.IV (2) :=
                 E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4);
               E.IV (3) :=
                 E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8);
               E.IV (4) :=
                 E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12);

            when CFB =>
               Encrypt (E.IV, E.Key);
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (E.Data, Pos);
               E.IV (2) := E.IV (2) xor To_Unsigned_32 (E.Data, Pos + 4);
               E.IV (3) := E.IV (3) xor To_Unsigned_32 (E.Data, Pos + 8);
               E.IV (4) := E.IV (4) xor To_Unsigned_32 (E.Data, Pos + 12);
               Put_Unsigned_32 (Into, E.IV (1), Last);
               Put_Unsigned_32 (Into, E.IV (2), Last + 4);
               Put_Unsigned_32 (Into, E.IV (3), Last + 8);
               Put_Unsigned_32 (Into, E.IV (4), Last + 12);

            when OFB =>
               Encrypt (E.IV, E.Key);
               Put_Unsigned_32
                 (Into, E.IV (1) xor To_Unsigned_32 (E.Data, Pos), Last);
               Put_Unsigned_32
                 (Into, E.IV (2) xor To_Unsigned_32 (E.Data, Pos + 4),
                  Last + 4);
               Put_Unsigned_32
                 (Into, E.IV (3) xor To_Unsigned_32 (E.Data, Pos + 8),
                  Last + 8);
               Put_Unsigned_32
                 (Into, E.IV (4) xor To_Unsigned_32 (E.Data, Pos + 12),
                  Last + 12);

            when CTR =>
               Encrypt (E.IV, R, E.Key);
               Put_Unsigned_32
                 (Into, R (1) xor To_Unsigned_32 (E.Data, Pos), Last);
               Put_Unsigned_32
                 (Into, R (2) xor To_Unsigned_32 (E.Data, Pos + 4), Last + 4);
               Put_Unsigned_32
                 (Into, R (3) xor To_Unsigned_32 (E.Data, Pos + 8), Last + 8);
               Put_Unsigned_32
                 (Into, R (4) xor To_Unsigned_32 (E.Data, Pos + 12),
                  Last + 12);
               E.IV (4) := E.IV (4) + 1;
               if E.IV (4) = 0 then
                  E.IV (3) := E.IV (3) + 1;
               end if;

         end case;

         Last         := Last + Block_Type'Length;
         E.Data_Count := 0;
      end if;

      Pos_Limit  := Data'Last - Block_Type'Length + 1;
      Last_Limit := Into'Last - Block_Type'Length + 1;
      case E.Mode is
         when ECB =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Encrypt
                 (Data (Pos .. Pos + Block_Type'Length - 1),
                  Into (Last .. Last + Block_Type'Length - 1), E.Key);
               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

         when CBC =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (Data, Pos);
               E.IV (2) := E.IV (2) xor To_Unsigned_32 (Data, Pos + 4);
               E.IV (3) := E.IV (3) xor To_Unsigned_32 (Data, Pos + 8);
               E.IV (4) := E.IV (4) xor To_Unsigned_32 (Data, Pos + 12);
               Encrypt (E.IV, E.Key);
               Put_Unsigned_32 (Into, E.IV (1), Last);
               Put_Unsigned_32 (Into, E.IV (2), Last + 4);
               Put_Unsigned_32 (Into, E.IV (3), Last + 8);
               Put_Unsigned_32 (Into, E.IV (4), Last + 12);
               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

         when PCBC =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (Data, Pos);
               E.IV (2) := E.IV (2) xor To_Unsigned_32 (Data, Pos + 4);
               E.IV (3) := E.IV (3) xor To_Unsigned_32 (Data, Pos + 8);
               E.IV (4) := E.IV (4) xor To_Unsigned_32 (Data, Pos + 12);
               Encrypt (E.IV, E.Key);
               Put_Unsigned_32 (Into, E.IV (1), Last);
               Put_Unsigned_32 (Into, E.IV (2), Last + 4);
               Put_Unsigned_32 (Into, E.IV (3), Last + 8);
               Put_Unsigned_32 (Into, E.IV (4), Last + 12);
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (Data, Pos);
               E.IV (2) := E.IV (2) xor To_Unsigned_32 (Data, Pos + 4);
               E.IV (3) := E.IV (3) xor To_Unsigned_32 (Data, Pos + 8);
               E.IV (4) := E.IV (4) xor To_Unsigned_32 (Data, Pos + 12);

               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

         when CFB =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Encrypt (E.IV, E.Key);
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (Data, Pos);
               E.IV (2) := E.IV (2) xor To_Unsigned_32 (Data, Pos + 4);
               E.IV (3) := E.IV (3) xor To_Unsigned_32 (Data, Pos + 8);
               E.IV (4) := E.IV (4) xor To_Unsigned_32 (Data, Pos + 12);
               Put_Unsigned_32 (Into, E.IV (1), Last);
               Put_Unsigned_32 (Into, E.IV (2), Last + 4);
               Put_Unsigned_32 (Into, E.IV (3), Last + 8);
               Put_Unsigned_32 (Into, E.IV (4), Last + 12);
               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

         when OFB =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Encrypt (E.IV, E.Key);
               Put_Unsigned_32
                 (Into, E.IV (1) xor To_Unsigned_32 (Data, Pos), Last);
               Put_Unsigned_32
                 (Into, E.IV (2) xor To_Unsigned_32 (Data, Pos + 4), Last + 4);
               Put_Unsigned_32
                 (Into, E.IV (3) xor To_Unsigned_32 (Data, Pos + 8), Last + 8);
               Put_Unsigned_32
                 (Into, E.IV (4) xor To_Unsigned_32 (Data, Pos + 12),
                  Last + 12);
               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

         when CTR =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Encrypt (E.IV, R, E.Key);
               Put_Unsigned_32
                 (Into, R (1) xor To_Unsigned_32 (Data, Pos), Last);
               Put_Unsigned_32
                 (Into, R (2) xor To_Unsigned_32 (Data, Pos + 4), Last + 4);
               Put_Unsigned_32
                 (Into, R (3) xor To_Unsigned_32 (Data, Pos + 8), Last + 8);
               Put_Unsigned_32
                 (Into, R (4) xor To_Unsigned_32 (Data, Pos + 12), Last + 12);
               E.IV (4) := E.IV (4) + 1;
               if E.IV (4) = 0 then
                  E.IV (3) := E.IV (3) + 1;
               end if;
               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

      end case;

      --  Save data that must be encoded in the next 16-byte AES block.
      while Pos <= Data'Last loop
         E.Data_Count          := E.Data_Count + 1;
         E.Data (E.Data_Count) := Data (Pos);
         Pos                   := Pos + 1;
         exit when E.Data_Count = Count_Type'Last;
      end loop;
      Last    := Last - 1;
      Encoded := Pos - 1;
   end Transform;

   --  Finish encoding the input array.
   overriding procedure Finish
     (E    : in out Encoder; Into : in out Ada.Streams.Stream_Element_Array;
      Last : in out Ada.Streams.Stream_Element_Offset)
   is
      Padding   : constant Ada.Streams.Stream_Element_Offset               :=
        16 - E.Data_Count;
      Pad_Value : constant Stream_Element                                  :=
        (if E.Padding = ZERO_PADDING then 0
         else Stream_Element (Padding mod 16));
      Pad       : constant Ada.Streams.Stream_Element_Array (1 .. Padding) :=
        (others => Pad_Value);
      Encoded   : Ada.Streams.Stream_Element_Offset;
   begin
      E.Transform (Pad, Into, Last, Encoded);

      pragma Assert (Encoded = Pad'Last);
      pragma Assert (E.Data_Count = 0);
   end Finish;

   --  ------------------------------
   --  Encrypt the secret using the encoder and return the encrypted value in the buffer.
   --  The target buffer must be a multiple of 16-bytes block.
   --  ------------------------------
   procedure Encrypt_Secret
     (E    : in out Encoder; Secret : in Secret_Key;
      Into :    out Ada.Streams.Stream_Element_Array)
   is
      Last    : Ada.Streams.Stream_Element_Offset;
      Encoded : Ada.Streams.Stream_Element_Offset;
   begin
      E.Transform
        (Data => Secret.Secret, Into => Into (Into'First .. Into'Last - 16),
         Last => Last, Encoded => Encoded);
      E.Finish (Into => Into (Last + 1 .. Into'Last), Last => Last);
   end Encrypt_Secret;

   --  ------------------------------
   --  Set the encryption key to use.
   --  ------------------------------
   procedure Set_Key
     (E : in out Decoder; Data : in Secret_Key; Mode : in AES_Mode := CBC)
   is
   begin
      if Mode in OFB | CFB | CTR then
         Set_Encrypt_Key (E.Key, Data);
      else
         Set_Decrypt_Key (E.Key, Data);
      end if;
      E.Mode := Mode;
   end Set_Key;

   --  ------------------------------
   --  Encodes the binary input stream represented by <b>Data</b> into
   --  an SHA-1 hash output stream <b>Into</b>.
   --
   --  If the transformer does not have enough room to write the result,
   --  it must return in <b>Encoded</b> the index of the last encoded
   --  position in the <b>Data</b> stream.
   --
   --  The transformer returns in <b>Last</b> the last valid position
   --  in the output stream <b>Into</b>.
   --
   --  The <b>Encoding_Error</b> exception is raised if the input
   --  stream cannot be transformed.
   --  ------------------------------
   overriding procedure Transform
     (E       : in out Decoder; Data : in Ada.Streams.Stream_Element_Array;
      Into    :    out Ada.Streams.Stream_Element_Array;
      Last    :    out Ada.Streams.Stream_Element_Offset;
      Encoded :    out Ada.Streams.Stream_Element_Offset)
   is
      Pos        : Ada.Streams.Stream_Element_Offset := Data'First;
      R          : Word_Block_Type;
      Pos_Limit  : Ada.Streams.Stream_Element_Offset;
      Last_Limit : Ada.Streams.Stream_Element_Offset;
   begin
      Last := Into'First;
      if E.Data_Count > 0 then
         while E.Data_Count /= 16 loop
            E.Data_Count          := E.Data_Count + 1;
            E.Data (E.Data_Count) := Data (Pos);
            Pos                   := Pos + 1;
            if Pos > Data'Last then
               Encoded := Data'Last;
               return;
            end if;
         end loop;

         --  Decrypt current block.
         case E.Mode is
            when ECB =>
               Decrypt
                 (E.Data, Into (Last .. Last + Block_Type'Length - 1), E.Key);

            when CBC =>
               Decrypt (E.Data, E.Data2, E.Key);
               Put_Unsigned_32
                 (Into, E.IV (1) xor To_Unsigned_32 (E.Data2, E.Data2'First),
                  Last);
               Put_Unsigned_32
                 (Into,
                  E.IV (2) xor To_Unsigned_32 (E.Data2, E.Data2'First + 4),
                  Last + 4);
               Put_Unsigned_32
                 (Into,
                  E.IV (3) xor To_Unsigned_32 (E.Data2, E.Data2'First + 8),
                  Last + 8);
               Put_Unsigned_32
                 (Into,
                  E.IV (4) xor To_Unsigned_32 (E.Data2, E.Data2'First + 12),
                  Last + 12);
               E.IV (1) := To_Unsigned_32 (E.Data, E.Data'First);
               E.IV (2) := To_Unsigned_32 (E.Data, E.Data'First + 4);
               E.IV (3) := To_Unsigned_32 (E.Data, E.Data'First + 8);
               E.IV (4) := To_Unsigned_32 (E.Data, E.Data'First + 12);

            when PCBC =>
               Decrypt (E.Data, E.Data2, E.Key);
               E.IV (1) :=
                 E.IV (1) xor To_Unsigned_32 (E.Data2, E.Data2'First);
               E.IV (2) :=
                 E.IV (2) xor To_Unsigned_32 (E.Data2, E.Data2'First + 4);
               E.IV (3) :=
                 E.IV (3) xor To_Unsigned_32 (E.Data2, E.Data2'First + 8);
               E.IV (4) :=
                 E.IV (4) xor To_Unsigned_32 (E.Data2, E.Data2'First + 12);
               Put_Unsigned_32 (Into, E.IV (1), Last);
               Put_Unsigned_32 (Into, E.IV (2), Last + 4);
               Put_Unsigned_32 (Into, E.IV (3), Last + 8);
               Put_Unsigned_32 (Into, E.IV (4), Last + 12);
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First);
               E.IV (2) :=
                 E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4);
               E.IV (3) :=
                 E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8);
               E.IV (4) :=
                 E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12);

            when CFB =>
               Encrypt (E.IV, E.Key);
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First);
               E.IV (2) :=
                 E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4);
               E.IV (3) :=
                 E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8);
               E.IV (4) :=
                 E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12);
               Put_Unsigned_32 (Into, E.IV (1), Last);
               Put_Unsigned_32 (Into, E.IV (2), Last + 4);
               Put_Unsigned_32 (Into, E.IV (3), Last + 8);
               Put_Unsigned_32 (Into, E.IV (4), Last + 12);

            when OFB =>
               Encrypt (E.IV, E.Key);
               Put_Unsigned_32
                 (Into, E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First),
                  Last);
               Put_Unsigned_32
                 (Into, E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4),
                  Last + 4);
               Put_Unsigned_32
                 (Into, E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8),
                  Last + 8);
               Put_Unsigned_32
                 (Into,
                  E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12),
                  Last + 12);

            when CTR =>
               Encrypt (E.IV, R, E.Key);
               Put_Unsigned_32
                 (Into, R (1) xor To_Unsigned_32 (E.Data, E.Data'First), Last);
               Put_Unsigned_32
                 (Into, R (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4),
                  Last + 4);
               Put_Unsigned_32
                 (Into, R (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8),
                  Last + 8);
               Put_Unsigned_32
                 (Into, R (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12),
                  Last + 12);
               E.IV (4) := E.IV (4) + 1;
               if E.IV (4) = 0 then
                  E.IV (3) := E.IV (3) + 1;
               end if;

         end case;

         Last         := Last + Block_Type'Length;
         E.Data_Count := 0;
      end if;

      --  Exclude the last 16 bytes
      Pos_Limit  := Data'Last - Block_Type'Length;
      Last_Limit := Into'Last - Block_Type'Length;
      case E.Mode is
         when ECB =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Decrypt
                 (Data (Pos .. Pos + Block_Type'Length - 1),
                  Into (Last .. Last + Block_Type'Length - 1), E.Key);
               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

         when CBC =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Decrypt
                 (Data (Pos .. Pos + Block_Type'Length - 1), E.Data, E.Key);
               Put_Unsigned_32
                 (Into, E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First),
                  Last);
               Put_Unsigned_32
                 (Into, E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4),
                  Last + 4);
               Put_Unsigned_32
                 (Into, E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8),
                  Last + 8);
               Put_Unsigned_32
                 (Into,
                  E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12),
                  Last + 12);
               E.IV (1) := To_Unsigned_32 (Data, Pos);
               E.IV (2) := To_Unsigned_32 (Data, Pos + 4);
               E.IV (3) := To_Unsigned_32 (Data, Pos + 8);
               E.IV (4) := To_Unsigned_32 (Data, Pos + 12);
               Last     := Last + Block_Type'Length;
               Pos      := Pos + Block_Type'Length;
            end loop;

         when PCBC =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Decrypt
                 (Data (Pos .. Pos + Block_Type'Length - 1), E.Data, E.Key);
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First);
               E.IV (2) :=
                 E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4);
               E.IV (3) :=
                 E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8);
               E.IV (4) :=
                 E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12);
               Put_Unsigned_32 (Into, E.IV (1), Last);
               Put_Unsigned_32 (Into, E.IV (2), Last + 4);
               Put_Unsigned_32 (Into, E.IV (3), Last + 8);
               Put_Unsigned_32 (Into, E.IV (4), Last + 12);
               E.IV (1) := E.IV (1) xor To_Unsigned_32 (Data, Pos);
               E.IV (2) := E.IV (2) xor To_Unsigned_32 (Data, Pos + 4);
               E.IV (3) := E.IV (3) xor To_Unsigned_32 (Data, Pos + 8);
               E.IV (4) := E.IV (4) xor To_Unsigned_32 (Data, Pos + 12);
               Last     := Last + Block_Type'Length;
               Pos      := Pos + Block_Type'Length;
            end loop;

         when CFB =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Encrypt (E.IV, E.Key);
               declare
                  Val : Unsigned_32;
               begin
                  Val := To_Unsigned_32 (Data, Pos);
                  Put_Unsigned_32 (Into, E.IV (1) xor Val, Last);
                  E.IV (1) := Val;
                  Val      := To_Unsigned_32 (Data, Pos + 4);
                  Put_Unsigned_32 (Into, E.IV (2) xor Val, Last + 4);
                  E.IV (2) := Val;
                  Val      := To_Unsigned_32 (Data, Pos + 8);
                  Put_Unsigned_32 (Into, E.IV (3) xor val, Last + 8);
                  E.IV (3) := Val;
                  Val      := To_Unsigned_32 (Data, Pos + 12);
                  Put_Unsigned_32 (Into, E.IV (4) xor Val, Last + 12);
                  E.IV (4) := Val;
               end;
               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

         when OFB =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Encrypt (E.IV, E.Key);
               Put_Unsigned_32
                 (Into, E.IV (1) xor To_Unsigned_32 (Data, Pos), Last);
               Put_Unsigned_32
                 (Into, E.IV (2) xor To_Unsigned_32 (Data, Pos + 4), Last + 4);
               Put_Unsigned_32
                 (Into, E.IV (3) xor To_Unsigned_32 (Data, Pos + 8), Last + 8);
               Put_Unsigned_32
                 (Into, E.IV (4) xor To_Unsigned_32 (Data, Pos + 12),
                  Last + 12);
               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

         when CTR =>
            while Pos <= Pos_Limit and then Last <= Last_Limit loop
               Encrypt (E.IV, R, E.Key);
               Put_Unsigned_32
                 (Into, R (1) xor To_Unsigned_32 (Data, Pos), Last);
               Put_Unsigned_32
                 (Into, R (2) xor To_Unsigned_32 (Data, Pos + 4), Last + 4);
               Put_Unsigned_32
                 (Into, R (3) xor To_Unsigned_32 (Data, Pos + 8), Last + 8);
               Put_Unsigned_32
                 (Into, R (4) xor To_Unsigned_32 (Data, Pos + 12), Last + 12);
               E.IV (4) := E.IV (4) + 1;
               if E.IV (4) = 0 then
                  E.IV (3) := E.IV (3) + 1;
               end if;
               Last := Last + Block_Type'Length;
               Pos  := Pos + Block_Type'Length;
            end loop;

      end case;

      --  Save data that must be encoded in the next 16-byte AES block.
      if Data'Last - Pos < E.Data'Length then
         while Pos <= Data'Last loop
            E.Data_Count          := E.Data_Count + 1;
            E.Data (E.Data_Count) := Data (Pos);
            Pos                   := Pos + 1;
            exit when E.Data_Count = Count_Type'Last;
         end loop;
      end if;
      Last    := Last - 1;
      Encoded := Pos - 1;
   end Transform;

   --  Finish encoding the input array.
   overriding procedure Finish
     (E    : in out Decoder; Into : in out Ada.Streams.Stream_Element_Array;
      Last : in out Ada.Streams.Stream_Element_Offset)
   is
      Data  : Block_Type;
      Count : Ada.Streams.Stream_Element_Offset;
   begin
      case E.Mode is
         when ECB =>
            Decrypt (E.Data, Data, E.Key);

         when CBC =>
            Decrypt (E.Data, Data, E.Key);
            Put_Unsigned_32
              (Data, E.IV (1) xor To_Unsigned_32 (Data, Data'First),
               Data'First);
            Put_Unsigned_32
              (Data, E.IV (2) xor To_Unsigned_32 (Data, Data'First + 4),
               Data'First + 4);
            Put_Unsigned_32
              (Data, E.IV (3) xor To_Unsigned_32 (Data, Data'First + 8),
               Data'First + 8);
            Put_Unsigned_32
              (Data, E.IV (4) xor To_Unsigned_32 (Data, Data'First + 12),
               Data'First + 12);
            E.IV (1) := To_Unsigned_32 (E.Data, E.Data'First);
            E.IV (2) := To_Unsigned_32 (E.Data, E.Data'First + 4);
            E.IV (3) := To_Unsigned_32 (E.Data, E.Data'First + 8);
            E.IV (4) := To_Unsigned_32 (E.Data, E.Data'First + 12);

         when PCBC =>
            Decrypt (E.Data, Data, E.Key);
            E.IV (1) := E.IV (1) xor To_Unsigned_32 (Data, Data'First);
            E.IV (2) := E.IV (2) xor To_Unsigned_32 (Data, Data'First + 4);
            E.IV (3) := E.IV (3) xor To_Unsigned_32 (Data, Data'First + 8);
            E.IV (4) := E.IV (4) xor To_Unsigned_32 (Data, Data'First + 12);
            Put_Unsigned_32 (Data, E.IV (1), Data'First);
            Put_Unsigned_32 (Data, E.IV (2), Data'First + 4);
            Put_Unsigned_32 (Data, E.IV (3), Data'First + 8);
            Put_Unsigned_32 (Data, E.IV (4), Data'First + 12);

         when OFB =>
            Encrypt (E.IV, E.Key);
            Put_Unsigned_32
              (Data, E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First),
               Data'First);
            Put_Unsigned_32
              (Data, E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4),
               Data'First + 4);
            Put_Unsigned_32
              (Data, E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8),
               Data'First + 8);
            Put_Unsigned_32
              (Data, E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12),
               Data'First + 12);

         when CFB =>
            Encrypt (E.IV, E.Key);
            E.IV (1) := E.IV (1) xor To_Unsigned_32 (E.Data, E.Data'First);
            E.IV (2) := E.IV (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4);
            E.IV (3) := E.IV (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8);
            E.IV (4) :=
              E.IV (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12);
            Put_Unsigned_32 (Data, E.IV (1), Data'First);
            Put_Unsigned_32 (Data, E.IV (2), Data'First + 4);
            Put_Unsigned_32 (Data, E.IV (3), Data'First + 8);
            Put_Unsigned_32 (Data, E.IV (4), Data'First + 12);

         when CTR =>
            declare
               R : Word_Block_Type;
            begin
               Encrypt (E.IV, R, E.Key);
               Put_Unsigned_32
                 (Data, R (1) xor To_Unsigned_32 (E.Data, E.Data'First),
                  Data'First);
               Put_Unsigned_32
                 (Data, R (2) xor To_Unsigned_32 (E.Data, E.Data'First + 4),
                  Data'First + 4);
               Put_Unsigned_32
                 (Data, R (3) xor To_Unsigned_32 (E.Data, E.Data'First + 8),
                  Data'First + 8);
               Put_Unsigned_32
                 (Data, R (4) xor To_Unsigned_32 (E.Data, E.Data'First + 12),
                  Data'First + 12);
            end;

      end case;

      if E.Padding = NO_PADDING then
         Last                      := Into'First + 16 - 1;
         Into (Into'First .. Last) := Data (Data'First .. Data'Last);
      elsif E.Padding = ZERO_PADDING then
         Last                      := Into'Last;
         Into (Into'First .. Last) :=
           Data (Data'First .. Data'First + Into'Length - 1);
      elsif Data (Data'Last) = 0 then
         Last := Into'First - 1;
      elsif Data (Data'Last) <= 15 then
         Count                     :=
           Data'Length - Ada.Streams.Stream_Element_Offset (Data (Data'Last));
         Last                      := Into'First + Count - 1;
         Into (Into'First .. Last) :=
           Data (Data'First .. Data'First + Count - 1);
      end if;
      E.Data_Count := 0;
   end Finish;

   --  Decrypt the content of data using the decoder and build the secret key.
   procedure Decrypt_Secret
     (E      : in out Decoder; Data : in Ada.Streams.Stream_Element_Array;
      Secret : in out Secret_Key)
   is
      Last    : Ada.Streams.Stream_Element_Offset;
      Encoded : Ada.Streams.Stream_Element_Offset;
   begin
      if E.Padding = NO_PADDING then
         E.Transform
           (Data => Data,
            Into => Secret.Secret (Secret.Secret'First .. Secret.Secret'Last),
            Last => Last, Encoded => Encoded);
         E.Finish
           (Into => Secret.Secret (Last + 1 .. Secret.Secret'Last),
            Last => Last);
      else
         E.Transform
           (Data => Data,
            Into =>
              Secret.Secret (Secret.Secret'First .. Secret.Secret'Last - 16),
            Last => Last, Encoded => Encoded);
         E.Finish
           (Into => Secret.Secret (Last + 1 .. Secret.Secret'Last),
            Last => Last);
      end if;
   end Decrypt_Secret;

   procedure Encrypt
     (Input  : in     Ada.Streams.Stream_Element_Array;
      Output :    out Ada.Streams.Stream_Element_Array;
      Last   :    out Ada.Streams.Stream_Element_Offset; Key : in Key_Type)
   is
      First  : Ada.Streams.Stream_Element_Offset := Input'First;
      Pad    : Ada.Streams.Stream_Element_Offset;
      Remain : Ada.Streams.Stream_Element_Offset;
   begin
      Last := Output'First;
      while First + 16 <= Input'Last loop
         Encrypt
           (Input (First .. First + 15), Output (Last .. Last + 15), Key);
         First := First + 16;
         Last  := Last + 16;
      end loop;
      Remain := Input'Last - First;
      if Remain > 0 then
         declare
            B : Block_Type;
         begin
            Pad                                 := B'Length - Remain;
            B (B'First .. B'First + Remain - 1) := Input (First .. Input'Last);
            B (B'First + Remain .. B'Last) := (others => Stream_Element (Pad));
            Encrypt (B, Output (Last .. Last + 16), Key);
            Last := Last + 16;
         end;
      end if;
   end Encrypt;

   procedure Encrypt (Data : in out Word_Block_Type; Key : in Key_Type) is
      S0, S1, S2, S3 : Unsigned_32;
      T0, T1, T2, T3 : Unsigned_32;
      N              : Natural := 0;
      R              : Natural := Key.Rounds / 2;
   begin
      S0 := Data (1) xor Key.Key (0);
      S1 := Data (2) xor Key.Key (1);
      S2 := Data (3) xor Key.Key (2);
      S3 := Data (4) xor Key.Key (3);
      loop
         T0 :=
           Te0 (Shift_Right (S0, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S1, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S2, 8) and 16#0ff#) xor Te3 (S3 and 16#0ff#) xor
           Key.Key (N + 4);

         T1 :=
           Te0 (Shift_Right (S1, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S2, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S3, 8) and 16#0ff#) xor Te3 (S0 and 16#0ff#) xor
           Key.Key (N + 5);

         T2 :=
           Te0 (Shift_Right (S2, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S3, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S0, 8) and 16#0ff#) xor Te3 (S1 and 16#0ff#) xor
           Key.Key (N + 6);

         T3 :=
           Te0 (Shift_Right (S3, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S0, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S1, 8) and 16#0ff#) xor Te3 (S2 and 16#0ff#) xor
           Key.Key (N + 7);

         N := N + 8;
         R := R - 1;
         exit when R = 0;

         S0 :=
           Te0 (Shift_Right (T0, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T1, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T2, 8) and 16#0ff#) xor Te3 (T3 and 16#0ff#) xor
           Key.Key (N + 0);

         S1 :=
           Te0 (Shift_Right (T1, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T2, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T3, 8) and 16#0ff#) xor Te3 (T0 and 16#0ff#) xor
           Key.Key (N + 1);

         S2 :=
           Te0 (Shift_Right (T2, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T3, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T0, 8) and 16#0ff#) xor Te3 (T1 and 16#0ff#) xor
           Key.Key (N + 2);

         S3 :=
           Te0 (Shift_Right (T3, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T0, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T1, 8) and 16#0ff#) xor Te3 (T2 and 16#0ff#) xor
           Key.Key (N + 3);

      end loop;

      S0       :=
        (Te2 (Shift_Right (T0, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T1, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T2, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T3 and 16#0ff#) and 16#0ff#) xor Key.Key (N);
      Data (1) := S0;

      S1       :=
        (Te2 (Shift_Right (T1, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T2, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T3, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T0 and 16#0ff#) and 16#0ff#) xor Key.Key (N + 1);
      Data (2) := S1;

      S2       :=
        (Te2 (Shift_Right (T2, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T3, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T0, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T1 and 16#0ff#) and 16#0ff#) xor Key.Key (N + 2);
      Data (3) := S2;

      S3       :=
        (Te2 (Shift_Right (T3, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T0, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T1, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T2 and 16#0ff#) and 16#0ff#) xor Key.Key (N + 3);
      Data (4) := S3;

   end Encrypt;

   procedure Encrypt
     (Input : in Word_Block_Type; Output : out Word_Block_Type;
      Key   : in Key_Type)
   is
      S0, S1, S2, S3 : Unsigned_32;
      T0, T1, T2, T3 : Unsigned_32;
      N              : Natural := 0;
      R              : Natural := Key.Rounds / 2;
   begin
      S0 := Input (1) xor Key.Key (0);
      S1 := Input (2) xor Key.Key (1);
      S2 := Input (3) xor Key.Key (2);
      S3 := Input (4) xor Key.Key (3);
      loop
         T0 :=
           Te0 (Shift_Right (S0, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S1, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S2, 8) and 16#0ff#) xor Te3 (S3 and 16#0ff#) xor
           Key.Key (N + 4);

         T1 :=
           Te0 (Shift_Right (S1, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S2, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S3, 8) and 16#0ff#) xor Te3 (S0 and 16#0ff#) xor
           Key.Key (N + 5);

         T2 :=
           Te0 (Shift_Right (S2, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S3, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S0, 8) and 16#0ff#) xor Te3 (S1 and 16#0ff#) xor
           Key.Key (N + 6);

         T3 :=
           Te0 (Shift_Right (S3, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S0, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S1, 8) and 16#0ff#) xor Te3 (S2 and 16#0ff#) xor
           Key.Key (N + 7);

         N := N + 8;
         R := R - 1;
         exit when R = 0;

         S0 :=
           Te0 (Shift_Right (T0, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T1, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T2, 8) and 16#0ff#) xor Te3 (T3 and 16#0ff#) xor
           Key.Key (N + 0);

         S1 :=
           Te0 (Shift_Right (T1, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T2, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T3, 8) and 16#0ff#) xor Te3 (T0 and 16#0ff#) xor
           Key.Key (N + 1);

         S2 :=
           Te0 (Shift_Right (T2, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T3, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T0, 8) and 16#0ff#) xor Te3 (T1 and 16#0ff#) xor
           Key.Key (N + 2);

         S3 :=
           Te0 (Shift_Right (T3, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T0, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T1, 8) and 16#0ff#) xor Te3 (T2 and 16#0ff#) xor
           Key.Key (N + 3);

      end loop;

      S0         :=
        (Te2 (Shift_Right (T0, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T1, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T2, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T3 and 16#0ff#) and 16#0ff#) xor Key.Key (N);
      Output (1) := S0;

      S1         :=
        (Te2 (Shift_Right (T1, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T2, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T3, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T0 and 16#0ff#) and 16#0ff#) xor Key.Key (N + 1);
      Output (2) := S1;

      S2         :=
        (Te2 (Shift_Right (T2, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T3, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T0, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T1 and 16#0ff#) and 16#0ff#) xor Key.Key (N + 2);
      Output (3) := S2;

      S3         :=
        (Te2 (Shift_Right (T3, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T0, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T1, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T2 and 16#0ff#) and 16#0ff#) xor Key.Key (N + 3);
      Output (4) := S3;

   end Encrypt;

   procedure Encrypt
     (Input : in Block_Type; Output : out Block_Type; Key : in Key_Type)
   is
      S0, S1, S2, S3 : Unsigned_32;
      T0, T1, T2, T3 : Unsigned_32;
      N              : Natural := 0;
      R              : Natural := Key.Rounds / 2;
   begin
      S0 := To_Unsigned_32 (Input, Input'First + 0) xor Key.Key (0);
      S1 := To_Unsigned_32 (Input, Input'First + 4) xor Key.Key (1);
      S2 := To_Unsigned_32 (Input, Input'First + 8) xor Key.Key (2);
      S3 := To_Unsigned_32 (Input, Input'First + 12) xor Key.Key (3);
      loop
         T0 :=
           Te0 (Shift_Right (S0, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S1, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S2, 8) and 16#0ff#) xor Te3 (S3 and 16#0ff#) xor
           Key.Key (N + 4);

         T1 :=
           Te0 (Shift_Right (S1, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S2, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S3, 8) and 16#0ff#) xor Te3 (S0 and 16#0ff#) xor
           Key.Key (N + 5);

         T2 :=
           Te0 (Shift_Right (S2, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S3, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S0, 8) and 16#0ff#) xor Te3 (S1 and 16#0ff#) xor
           Key.Key (N + 6);

         T3 :=
           Te0 (Shift_Right (S3, 24) and 16#0ff#) xor
           Te1 (Shift_Right (S0, 16) and 16#0ff#) xor
           Te2 (Shift_Right (S1, 8) and 16#0ff#) xor Te3 (S2 and 16#0ff#) xor
           Key.Key (N + 7);

         N := N + 8;
         R := R - 1;
         exit when R = 0;

         S0 :=
           Te0 (Shift_Right (T0, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T1, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T2, 8) and 16#0ff#) xor Te3 (T3 and 16#0ff#) xor
           Key.Key (N + 0);

         S1 :=
           Te0 (Shift_Right (T1, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T2, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T3, 8) and 16#0ff#) xor Te3 (T0 and 16#0ff#) xor
           Key.Key (N + 1);

         S2 :=
           Te0 (Shift_Right (T2, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T3, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T0, 8) and 16#0ff#) xor Te3 (T1 and 16#0ff#) xor
           Key.Key (N + 2);

         S3 :=
           Te0 (Shift_Right (T3, 24) and 16#0ff#) xor
           Te1 (Shift_Right (T0, 16) and 16#0ff#) xor
           Te2 (Shift_Right (T1, 8) and 16#0ff#) xor Te3 (T2 and 16#0ff#) xor
           Key.Key (N + 3);

      end loop;

      S0 :=
        (Te2 (Shift_Right (T0, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T1, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T2, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T3 and 16#0ff#) and 16#0ff#) xor Key.Key (N);
      Put_Unsigned_32 (Output, S0, Output'First + 0);

      S1 :=
        (Te2 (Shift_Right (T1, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T2, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T3, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T0 and 16#0ff#) and 16#0ff#) xor Key.Key (N + 1);
      Put_Unsigned_32 (Output, S1, Output'First + 4);

      S2 :=
        (Te2 (Shift_Right (T2, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T3, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T0, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T1 and 16#0ff#) and 16#0ff#) xor Key.Key (N + 2);
      Put_Unsigned_32 (Output, S2, Output'First + 8);

      S3 :=
        (Te2 (Shift_Right (T3, 24) and 16#0ff#) and 16#ff00_0000#) xor
        (Te3 (Shift_Right (T0, 16) and 16#0ff#) and 16#00ff_0000#) xor
        (Te0 (Shift_Right (T1, 8) and 16#0ff#) and 16#0_ff00#) xor
        (Te1 (T2 and 16#0ff#) and 16#0ff#) xor Key.Key (N + 3);
      Put_Unsigned_32 (Output, S3, Output'First + 12);

   end Encrypt;

   procedure Decrypt
     (Input : in Block_Type; Output : out Block_Type; Key : in Key_Type)
   is
      S0, S1, S2, S3 : Unsigned_32;
      T0, T1, T2, T3 : Unsigned_32;
      N              : Natural := 0;
      R              : Natural := Key.Rounds / 2;
   begin
      S0 := To_Unsigned_32 (Input, Input'First + 0) xor Key.Key (0);
      S1 := To_Unsigned_32 (Input, Input'First + 4) xor Key.Key (1);
      S2 := To_Unsigned_32 (Input, Input'First + 8) xor Key.Key (2);
      S3 := To_Unsigned_32 (Input, Input'First + 12) xor Key.Key (3);
      loop
         T0 :=
           Td0 (Shift_Right (S0, 24) and 16#0ff#) xor
           Td1 (Shift_Right (S3, 16) and 16#0ff#) xor
           Td2 (Shift_Right (S2, 8) and 16#0ff#) xor Td3 (S1 and 16#0ff#) xor
           Key.Key (N + 4);

         T1 :=
           Td0 (Shift_Right (S1, 24) and 16#0ff#) xor
           Td1 (Shift_Right (S0, 16) and 16#0ff#) xor
           Td2 (Shift_Right (S3, 8) and 16#0ff#) xor Td3 (S2 and 16#0ff#) xor
           Key.Key (N + 5);

         T2 :=
           Td0 (Shift_Right (S2, 24) and 16#0ff#) xor
           Td1 (Shift_Right (S1, 16) and 16#0ff#) xor
           Td2 (Shift_Right (S0, 8) and 16#0ff#) xor Td3 (S3 and 16#0ff#) xor
           Key.Key (N + 6);

         T3 :=
           Td0 (Shift_Right (S3, 24) and 16#0ff#) xor
           Td1 (Shift_Right (S2, 16) and 16#0ff#) xor
           Td2 (Shift_Right (S1, 8) and 16#0ff#) xor Td3 (S0 and 16#0ff#) xor
           Key.Key (N + 7);

         N := N + 8;
         R := R - 1;
         exit when R = 0;

         S0 :=
           Td0 (Shift_Right (T0, 24) and 16#0ff#) xor
           Td1 (Shift_Right (T3, 16) and 16#0ff#) xor
           Td2 (Shift_Right (T2, 8) and 16#0ff#) xor Td3 (T1 and 16#0ff#) xor
           Key.Key (N + 0);

         S1 :=
           Td0 (Shift_Right (T1, 24) and 16#0ff#) xor
           Td1 (Shift_Right (T0, 16) and 16#0ff#) xor
           Td2 (Shift_Right (T3, 8) and 16#0ff#) xor Td3 (T2 and 16#0ff#) xor
           Key.Key (N + 1);

         S2 :=
           Td0 (Shift_Right (T2, 24) and 16#0ff#) xor
           Td1 (Shift_Right (T1, 16) and 16#0ff#) xor
           Td2 (Shift_Right (T0, 8) and 16#0ff#) xor Td3 (T3 and 16#0ff#) xor
           Key.Key (N + 2);

         S3 :=
           Td0 (Shift_Right (T3, 24) and 16#0ff#) xor
           Td1 (Shift_Right (T2, 16) and 16#0ff#) xor
           Td2 (Shift_Right (T1, 8) and 16#0ff#) xor Td3 (T0 and 16#0ff#) xor
           Key.Key (N + 3);

      end loop;

      S0 :=
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T0, 24) and 16#0ff#)), 24) xor
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T3, 16) and 16#0ff#)), 16) xor
        Shift_Left (Unsigned_32 (Td4 (Shift_Right (T2, 8) and 16#0ff#)), 8) xor
        Unsigned_32 (Td4 (T1 and 16#0ff#)) xor Key.Key (N);
      Put_Unsigned_32 (Output, S0, Output'First + 0);

      S1 :=
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T1, 24) and 16#0ff#)), 24) xor
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T0, 16) and 16#0ff#)), 16) xor
        Shift_Left (Unsigned_32 (Td4 (Shift_Right (T3, 8) and 16#0ff#)), 8) xor
        Unsigned_32 (Td4 (T2 and 16#0ff#)) xor Key.Key (N + 1);
      Put_Unsigned_32 (Output, S1, Output'First + 4);

      S2 :=
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T2, 24) and 16#0ff#)), 24) xor
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T1, 16) and 16#0ff#)), 16) xor
        Shift_Left (Unsigned_32 (Td4 (Shift_Right (T0, 8) and 16#0ff#)), 8) xor
        Unsigned_32 (Td4 (T3 and 16#0ff#)) xor Key.Key (N + 2);
      Put_Unsigned_32 (Output, S2, Output'First + 8);

      S3 :=
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T3, 24) and 16#0ff#)), 24) xor
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T2, 16) and 16#0ff#)), 16) xor
        Shift_Left (Unsigned_32 (Td4 (Shift_Right (T1, 8) and 16#0ff#)), 8) xor
        Unsigned_32 (Td4 (T0 and 16#0ff#)) xor Key.Key (N + 3);
      Put_Unsigned_32 (Output, S3, Output'First + 12);

   end Decrypt;

   procedure Decrypt
     (Input : in Word_Block_Type; Output : out Word_Block_Type;
      Key   : in Key_Type)
   is
      S0, S1, S2, S3 : Unsigned_32;
      T0, T1, T2, T3 : Unsigned_32;
      N              : Natural := 0;
      R              : Natural := Key.Rounds / 2;
   begin
      S0 := Input (1) xor Key.Key (0);
      S1 := Input (2) xor Key.Key (1);
      S2 := Input (3) xor Key.Key (2);
      S3 := Input (4) xor Key.Key (3);
      loop
         T0 :=
           Td0 (Shift_Right (S0, 24) and 16#0ff#) xor
           Td1 (Shift_Right (S3, 16) and 16#0ff#) xor
           Td2 (Shift_Right (S2, 8) and 16#0ff#) xor Td3 (S1 and 16#0ff#) xor
           Key.Key (N + 4);

         T1 :=
           Td0 (Shift_Right (S1, 24) and 16#0ff#) xor
           Td1 (Shift_Right (S0, 16) and 16#0ff#) xor
           Td2 (Shift_Right (S3, 8) and 16#0ff#) xor Td3 (S2 and 16#0ff#) xor
           Key.Key (N + 5);

         T2 :=
           Td0 (Shift_Right (S2, 24) and 16#0ff#) xor
           Td1 (Shift_Right (S1, 16) and 16#0ff#) xor
           Td2 (Shift_Right (S0, 8) and 16#0ff#) xor Td3 (S3 and 16#0ff#) xor
           Key.Key (N + 6);

         T3 :=
           Td0 (Shift_Right (S3, 24) and 16#0ff#) xor
           Td1 (Shift_Right (S2, 16) and 16#0ff#) xor
           Td2 (Shift_Right (S1, 8) and 16#0ff#) xor Td3 (S0 and 16#0ff#) xor
           Key.Key (N + 7);

         N := N + 8;
         R := R - 1;
         exit when R = 0;

         S0 :=
           Td0 (Shift_Right (T0, 24) and 16#0ff#) xor
           Td1 (Shift_Right (T3, 16) and 16#0ff#) xor
           Td2 (Shift_Right (T2, 8) and 16#0ff#) xor Td3 (T1 and 16#0ff#) xor
           Key.Key (N + 0);

         S1 :=
           Td0 (Shift_Right (T1, 24) and 16#0ff#) xor
           Td1 (Shift_Right (T0, 16) and 16#0ff#) xor
           Td2 (Shift_Right (T3, 8) and 16#0ff#) xor Td3 (T2 and 16#0ff#) xor
           Key.Key (N + 1);

         S2 :=
           Td0 (Shift_Right (T2, 24) and 16#0ff#) xor
           Td1 (Shift_Right (T1, 16) and 16#0ff#) xor
           Td2 (Shift_Right (T0, 8) and 16#0ff#) xor Td3 (T3 and 16#0ff#) xor
           Key.Key (N + 2);

         S3 :=
           Td0 (Shift_Right (T3, 24) and 16#0ff#) xor
           Td1 (Shift_Right (T2, 16) and 16#0ff#) xor
           Td2 (Shift_Right (T1, 8) and 16#0ff#) xor Td3 (T0 and 16#0ff#) xor
           Key.Key (N + 3);

      end loop;

      S0         :=
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T0, 24) and 16#0ff#)), 24) xor
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T3, 16) and 16#0ff#)), 16) xor
        Shift_Left (Unsigned_32 (Td4 (Shift_Right (T2, 8) and 16#0ff#)), 8) xor
        Unsigned_32 (Td4 (T1 and 16#0ff#)) xor Key.Key (N);
      Output (1) := S0;

      S1         :=
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T1, 24) and 16#0ff#)), 24) xor
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T0, 16) and 16#0ff#)), 16) xor
        Shift_Left (Unsigned_32 (Td4 (Shift_Right (T3, 8) and 16#0ff#)), 8) xor
        Unsigned_32 (Td4 (T2 and 16#0ff#)) xor Key.Key (N + 1);
      Output (2) := S1;

      S2         :=
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T2, 24) and 16#0ff#)), 24) xor
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T1, 16) and 16#0ff#)), 16) xor
        Shift_Left (Unsigned_32 (Td4 (Shift_Right (T0, 8) and 16#0ff#)), 8) xor
        Unsigned_32 (Td4 (T3 and 16#0ff#)) xor Key.Key (N + 2);
      Output (3) := S2;

      S3         :=
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T3, 24) and 16#0ff#)), 24) xor
        Shift_Left
          (Unsigned_32 (Td4 (Shift_Right (T2, 16) and 16#0ff#)), 16) xor
        Shift_Left (Unsigned_32 (Td4 (Shift_Right (T1, 8) and 16#0ff#)), 8) xor
        Unsigned_32 (Td4 (T0 and 16#0ff#)) xor Key.Key (N + 3);
      Output (4) := S3;

   end Decrypt;

end Util.Encoders.AES;
